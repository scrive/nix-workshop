<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scrive Nix Workshop</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Scrive Nix Workshop</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="01-getting-started/01-introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="01-getting-started/02-installation.html"><strong aria-hidden="true">3.</strong> Installation</a></li><li class="chapter-item expanded "><a href="01-getting-started/03-resources.html"><strong aria-hidden="true">4.</strong> Resources</a></li><li class="chapter-item expanded affix "><li class="part-title">Nix Commands</li><li class="chapter-item expanded "><a href="02-nix-commands/01-install-global-packages.html"><strong aria-hidden="true">5.</strong> Installing Global Packages</a></li><li class="chapter-item expanded "><a href="02-nix-commands/02-use-packages-in-nix-shell.html"><strong aria-hidden="true">6.</strong> Using Packages in Nix shell</a></li><li class="chapter-item expanded "><a href="02-nix-commands/03-nix-repl.html"><strong aria-hidden="true">7.</strong> Nix Repl</a></li><li class="chapter-item expanded affix "><li class="part-title">Nix Basics</li><li class="chapter-item expanded "><a href="03-nix-basics/01-primitives.html"><strong aria-hidden="true">8.</strong> Nix Primitives</a></li><li class="chapter-item expanded "><a href="03-nix-basics/02-expressions.html"><strong aria-hidden="true">9.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="03-nix-basics/03-files.html"><strong aria-hidden="true">10.</strong> Files</a></li><li class="chapter-item expanded "><a href="03-nix-basics/04-import.html"><strong aria-hidden="true">11.</strong> Import</a></li><li class="chapter-item expanded affix "><li class="part-title">Derivations</li><li class="chapter-item expanded "><a href="04-derivations/01-derivation-basics.html"><strong aria-hidden="true">12.</strong> Derivation Basics</a></li><li class="chapter-item expanded "><a href="04-derivations/02-dependencies.html"><strong aria-hidden="true">13.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="04-derivations/03-fibonacci.html"><strong aria-hidden="true">14.</strong> Fibonacci</a></li><li class="chapter-item expanded "><a href="04-derivations/04-raw-derivation.html"><strong aria-hidden="true">15.</strong> Raw Derivation</a></li><li class="chapter-item expanded "><a href="04-derivations/05-standard-derivation.html"><strong aria-hidden="true">16.</strong> Standard Derivation</a></li><li class="chapter-item expanded "><a href="04-derivations/06-build-phases.html"><strong aria-hidden="true">17.</strong> Build Phases</a></li><li class="chapter-item expanded affix "><li class="part-title">Package Management</li><li class="chapter-item expanded "><a href="05-package-management/01-dependency-management.html"><strong aria-hidden="true">18.</strong> Dependency Management</a></li><li class="chapter-item expanded "><a href="05-package-management/02-basic-haskell.html"><strong aria-hidden="true">19.</strong> Basic Haskell Project</a></li><li class="chapter-item expanded "><a href="05-package-management/03-version-conflicts.html"><strong aria-hidden="true">20.</strong> Version Conflicts</a></li><li class="chapter-item expanded "><a href="05-package-management/04-transitive-version-conflicts.html"><strong aria-hidden="true">21.</strong> Transitive Version Conflicts</a></li><li class="chapter-item expanded "><a href="05-package-management/05-multi-versioned-haskell-packages.html"><strong aria-hidden="true">22.</strong> Multi-versioned Haskell Packages</a></li><li class="chapter-item expanded "><a href="05-package-management/06-other-strategies.html"><strong aria-hidden="true">23.</strong> Other Package Management Strategies</a></li><li class="chapter-item expanded affix "><li class="part-title">Infrastructure</li><li class="chapter-item expanded "><a href="06-infrastructure/01-caching-nix.html"><strong aria-hidden="true">24.</strong> Caching Nix Packages</a></li><li class="chapter-item expanded "><a href="06-infrastructure/02-caching-haskell.html"><strong aria-hidden="true">25.</strong> Caching Haskell Nix Packages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Scrive Nix Workshop</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#scrive-nix-workshop" id="scrive-nix-workshop">Scrive Nix Workshop</a></h1>
<p>Welcome to Scrive Nix Workshop! This book contains the workshop materials
used for training Haskell developers at <a href="https://www.scrive.com/">Scrive</a>.
(We are <a href="https://careers.scrive.com/jobs/996814-haskell-developer">hiring Haskell developers</a>!)</p>
<p>We are open sourcing this content so that the Nix community can also benefit
from the content and make contribution to improve it.</p>
<p>The content in this workshop is currently organized based on the workshop sessions
we have held at Scrive. With the materials open sourced, we welcome to changes
to make this more catered for the general audience in the Nix community.
We hope that the current materials are still useful for more people to learn
about Nix.</p>
<p>Nix is a rather difficult subject with a steep learning curve, even for us!
So this is also our chance to learn from the rest of the Nix community.
If there is any mistake or misconception in this book, do let us know!</p>
<h2><a class="header" href="#build-instructions" id="build-instructions">Build Instructions</a></h2>
<p>A HTML version of this workshop is published at
<a href="https://scrive.github.io/nix-workshop/">https://scrive.github.io/nix-workshop/</a>.
The source code of this workshop is available on
<a href="https://github.com/scrive/nix-workshop">GitHub</a>.
This workshop material is built using
<a href="https://rust-lang.github.io/mdBook/">mdbook</a>.</p>
<p>To view this book, first <a href="https://nixos.org/download.html">install Nix</a>,
and then run:</p>
<pre><code class="language-bash">make serve
</code></pre>
<p>You can then browse to <a href="http://localhost:3000">http://localhost:3000</a> to view the book webpage.</p>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>Copyright (c) 2020-2021 Scrive AB.
This work is licensed under both the
<a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
and
the <a href="https://opensource.org/licenses/MIT">MIT license</a>.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>What is Nix?</p>
<h2><a class="header" href="#programming-language" id="programming-language">Programming Language</a></h2>
<ul>
<li>
<p>Dynamic typed - Similar semantics with JavaScript and Lisp.</p>
</li>
<li>
<p>Functional programming - Higher order functions, immutability, etc.</p>
</li>
<li>
<p>Lazy - Values are not evaluated until needed.</p>
</li>
</ul>
<h2><a class="header" href="#package-manager" id="package-manager">Package Manager</a></h2>
<ul>
<li>
<p>Packages as special Nix objects that produce derivations and build artifacts.</p>
</li>
<li>
<p>One package can serve as build input of another package.</p>
</li>
<li>
<p>Multiple versions of the &quot;same&quot; package can present on the same system.</p>
</li>
</ul>
<h2><a class="header" href="#build-system" id="build-system">Build System</a></h2>
<ul>
<li>
<p>Packages are built from source code.</p>
</li>
<li>
<p>Build artifacts of packages are cached based on content address (SHA256 checksum).</p>
</li>
<li>
<p>Multi language / multi repository build system.</p>
<ul>
<li>Language agnostic.</li>
<li>Construct your own build system pipeline.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#operating-system" id="operating-system">Operating System</a></h2>
<ul>
<li>
<p>Nix itself is a pseudo operating system.</p>
<ul>
<li>Rich set of Nix packages that can typically be found in OS packages.</li>
</ul>
</li>
<li>
<p>Nix packages can co-exist non-destructively with native OS packages.</p>
<ul>
<li>
<p>All Nix artifacts are stored in <code>/nix</code>.</p>
</li>
<li>
<p>Global &quot;installation&quot; are merely symlink to Nix artifacts in
<code>/nix/store</code>.</p>
</li>
</ul>
</li>
<li>
<p>Lightweight activation of global Nix packages.</p>
<ul>
<li>
<p>Add <code>~/.nix-profile/bin/</code> to <code>$PATH</code>.</p>
</li>
<li>
<p>Call <code>source ~/.nix-profile/etc/profile.d/nix.sh</code> to activate Nix.</p>
</li>
<li>
<p>Otherwise Nix is almost invisible to users if it is not activated.</p>
</li>
</ul>
</li>
<li>
<p>NixOS as a full Linux operating system.</p>
</li>
</ul>
<h2><a class="header" href="#reproducibility" id="reproducibility">Reproducibility</a></h2>
<ul>
<li>
<p>Key differentiation of Nix as compared to other solutions.</p>
</li>
<li>
<p>Nix packages are built inside a lightweight sandbox.</p>
<ul>
<li>
<p>No containerization.</p>
</li>
<li>
<p>Sanitize all environment variables.</p>
</li>
<li>
<p>Special <code>$HOME</code> directory at <code>/homeless-shelter</code>.</p>
</li>
<li>
<p>Reset date to Unix time 0.</p>
</li>
<li>
<p>Very difficult to accidentally escape the sandbox.</p>
</li>
</ul>
</li>
<li>
<p>Content addressable storage.</p>
<ul>
<li>
<p>Address of Nix packages are based on checksum of source code,
plus other factors such as CPU architecture and operating system.</p>
</li>
<li>
<p>If checksum of source code changes, the address of the derivation
and build artifact also changes.</p>
</li>
<li>
<p>If the address of a dependency changes, the address of the
derivation and build artifact also changes.</p>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>Download available at https://nixos.org/download.html.</p>
<p>Simplest way is to run:</p>
<pre><code class="language-bash">$ curl -L https://nixos.org/nix/install | sh
</code></pre>
<p>After installation, you might need to relogin to your shell to
reload the environment. Otherwise, run the following to use
Nix immediately:</p>
<pre><code class="language-bash">source ~/.nix-profile/etc/profile.d/nix.sh
</code></pre>
<p>You may want to configure to load this automatically in <code>~/.bashrc</code> or similar
file.</p>
<h2><a class="header" href="#update" id="update">Update</a></h2>
<p>If you have installed Nix before but have not updated it for a while,
you should update it with:</p>
<pre><code class="language-bash">nix-channel --update
</code></pre>
<p>This helps ensure we are installing the latest version of packages
in global installation and global imports.</p>
<h1><a class="header" href="#learning-resources-for-nix" id="learning-resources-for-nix">Learning Resources for Nix</a></h1>
<ul>
<li>
<p><a href="https://nixos.org/learn.html">Official Nix Manuals</a>:</p>
<ul>
<li><a href="https://nixos.org/manual/nix/unstable">Nix Manual</a> - Information about <code>nix</code>-the-command and the Nix Language.</li>
<li><a href="https://nixos.org/manual/nixpkgs/unstable">Nixpkgs Manual</a> - Information about the Nix Package Set (<code>nixpkgs</code>). How to extend and customise packages, how each language ecosystem is packaged, etc.</li>
<li><a href="https://nixos.org/manual/nixos/unstable">NixOS Manual</a> - Information about the NixOS operating system. How to install/configure/update NixOS, the DSL for describing configuration options, etc.</li>
</ul>
</li>
<li>
<p><a href="https://nix.dev/">nix.dev</a> - Pragmatic guide on how to use Nix productively.</p>
</li>
<li>
<p><a href="https://github.com/nix-community/awesome-nix">Awesome Nix</a> - Curated list of
Nix resources.</p>
</li>
<li>
<p><a href="https://nixos.org/guides/nix-pills/">Nix Pills</a> - Alternative Nix tutorial. Takes a bottom-up approach, explaining Nix and Nixpkgs design patterns along the way.</p>
</li>
<li>
<p><a href="https://github.com/Gabriel439/haskell-nix">Gabriel439's Nix and Haskell tutorial</a></p>
</li>
</ul>
<h1><a class="header" href="#install-global-packages" id="install-global-packages">Install Global Packages</a></h1>
<pre><code class="language-bash">$ nix-env -i hello
installing 'hello-2.10'
building '/nix/store/mlfrpy1ahv3arh2n23p45vdpm0p4nl1x-user-environment.drv'...
created 39 symlinks in user environment
</code></pre>
<pre><code class="language-bash">$ hello
Hello, world!

$ which hello
/home/user/.nix-profile/bin/hello

$ readlink $(which hello)
/nix/store/ylhzcjbchfihsrpsg0dxx9niwzp35y63-hello-2.10/bin/hello
</code></pre>
<h2><a class="header" href="#uninstall" id="uninstall">Uninstall</a></h2>
<pre><code class="language-bash">$ nix-env --uninstall hello
uninstalling 'hello-2.10'
</code></pre>
<h1><a class="header" href="#nix-shell" id="nix-shell">Nix Shell</a></h1>
<p>You can use Nix packages without installing them globally on your machine.</p>
<pre><code class="language-bash">$ nix-shell -p hello

[nix-shell:nix-workshop]$ hello
Hello, world!
</code></pre>
<h2><a class="header" href="#using-multiple-packages" id="using-multiple-packages">Using Multiple Packages</a></h2>
<pre><code class="language-bash">$ nix-shell -p nodejs ghc cabal-install

[nix-shell:nix-workshop]$ which node
/nix/store/ndkzg5kpyp92mlzh5h66l4j393x6b256-nodejs-12.19.0/bin/node

[nix-shell:nix-workshop]$ which ghc
/nix/store/sbqnpfnx4w8jb7jq2yb71pifihwqy2a5-ghc-8.8.4/bin/ghc

[nix-shell:nix-workshop]$ which cabal
/nix/store/060x141b9fz2pm6yz4zn3i0ncavbdbf7-cabal-install-3.2.0.0/bin/cabal
</code></pre>
<h1><a class="header" href="#nix-repl" id="nix-repl">Nix Repl</a></h1>
<pre><code class="language-bash">nix repl
Welcome to Nix version 2.3.8. Type :? for help.

nix-repl&gt; &quot;Hello World!&quot;
&quot;Hello World!&quot;
</code></pre>
<h1><a class="header" href="#nix-primitives" id="nix-primitives">Nix Primitives</a></h1>
<h2><a class="header" href="#strings" id="strings">Strings</a></h2>
<pre><code class="language-nix">nix-repl&gt; &quot;hello&quot;
&quot;hello&quot;
</code></pre>
<h2><a class="header" href="#booleans" id="booleans">Booleans</a></h2>
<pre><code class="language-nix">nix-repl&gt; true
true

nix-repl&gt; false
false

nix-repl&gt; true &amp;&amp; false
false

nix-repl&gt; true || false
true
</code></pre>
<h2><a class="header" href="#null" id="null">Null</a></h2>
<pre><code class="language-nix">nix-repl&gt; null
null

nix-repl&gt; true &amp;&amp; null
error: value is null while a Boolean was expected, at (string):1:1
</code></pre>
<h2><a class="header" href="#numbers" id="numbers">Numbers</a></h2>
<pre><code class="language-nix">nix-repl&gt; 1
1

nix-repl&gt; 2
2

nix-repl&gt; 1 + 2
3
</code></pre>
<h2><a class="header" href="#string-interpolation" id="string-interpolation">String Interpolation</a></h2>
<pre><code class="language-nix">nix-repl&gt; name = &quot;John&quot;

nix-repl&gt; name
&quot;John&quot;

nix-repl&gt; &quot;Hello, ${name}!&quot;
&quot;Hello, John!&quot;
</code></pre>
<h2><a class="header" href="#multi-line-strings" id="multi-line-strings">Multi Line Strings</a></h2>
<pre><code class="language-nix">nix-repl&gt; ''
            Lorem ipsum dolor sit amet, consectetur adipiscing elit.
              Nullam augue ligula, pharetra quis mi porta.

            - ${name}
          ''
&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n  Nullam augue ligula, pharetra quis mi porta.\n\n- John\n&quot;
</code></pre>
<h2><a class="header" href="#string-concatenation" id="string-concatenation">String Concatenation</a></h2>
<pre><code class="language-nix">nix-repl&gt; &quot;Hello &quot; + &quot;World&quot;
&quot;Hello World&quot;

nix-repl&gt; &quot;Hello &quot; + 123
error: cannot coerce an integer to a string, at (string):1:1
</code></pre>
<h2><a class="header" href="#set--object" id="set--object">Set / Object</a></h2>
<pre><code class="language-nix">nix-repl&gt; object = { foo = &quot;foo val&quot;; bar = &quot;bar val&quot;; }

nix-repl&gt; object
{ bar = &quot;bar val&quot;; foo = &quot;foo val&quot;; }

nix-repl&gt; object.foo
&quot;foo val&quot;

nix-repl&gt; object.bar
&quot;bar val&quot;
</code></pre>
<h2><a class="header" href="#merge-objects" id="merge-objects">Merge Objects</a></h2>
<pre><code class="language-nix">nix-repl&gt; a = { foo = &quot;foo val&quot;; bar = &quot;bar val&quot;; }

nix-repl&gt; b = { foo = &quot;override&quot;; baz = &quot;baz val&quot;; }

nix-repl&gt; a // b
{ bar = &quot;bar val&quot;; baz = &quot;baz val&quot;; foo = &quot;override&quot;; }
</code></pre>
<h2><a class="header" href="#inherit" id="inherit">Inherit</a></h2>
<pre><code class="language-nix">nix-repl&gt; foo = &quot;foo val&quot;

nix-repl&gt; bar = &quot;bar val&quot;

nix-repl&gt; { foo = foo; bar = bar; }
{ bar = &quot;bar val&quot;; foo = &quot;foo val&quot;; }

nix-repl&gt; { inherit foo bar; }
{ bar = &quot;bar val&quot;; foo = &quot;foo val&quot;; }
</code></pre>
<h2><a class="header" href="#inherit-from-object" id="inherit-from-object">Inherit From Object</a></h2>
<pre><code class="language-nix">nix-repl&gt; let
            object = {
              foo = &quot;foo val&quot;;
              bar = &quot;bar val&quot;;
            };
          in
          {
            foo = object.foo;

            baz = &quot;baz val&quot;;
          }
{ baz = &quot;baz val&quot;; foo = &quot;foo val&quot;; }
</code></pre>
<pre><code class="language-nix">nix-repl&gt; let
            object = {
              foo = &quot;foo val&quot;;
              bar = &quot;bar val&quot;;
            };
          in
          {
            inherit (object) foo;

            baz = &quot;baz val&quot;;
          }
{ baz = &quot;baz val&quot;; foo = &quot;foo val&quot;; }
</code></pre>
<h2><a class="header" href="#list" id="list">List</a></h2>
<pre><code class="language-nix">nix-repl&gt; list = [ &quot;hello&quot; 123 { foo = &quot;foo&quot;; } ]

nix-repl&gt; list
[ &quot;hello&quot; 123 { ... } ]

nix-repl&gt; builtins.elemAt list 2
{ foo = &quot;foo&quot;; }
</code></pre>
<h2><a class="header" href="#list-concatenation" id="list-concatenation">List Concatenation</a></h2>
<pre><code class="language-nix">nix-repl&gt; [ 1 2 ] ++ [ &quot;foo&quot; &quot;bar&quot; ]
[ 1 2 &quot;foo&quot; &quot;bar&quot; ]
</code></pre>
<h1><a class="header" href="#nix-expressions" id="nix-expressions">Nix Expressions</a></h1>
<h2><a class="header" href="#if-expression" id="if-expression">If Expression</a></h2>
<pre><code class="language-nix">nix-repl&gt; if true then 0 else 1
0

nix-repl&gt; if false then 0 else &quot;foo&quot;
&quot;foo&quot;

nix-repl&gt; if null then 1 else 2
error: value is null while a Boolean was expected
</code></pre>
<h2><a class="header" href="#let-expression" id="let-expression">Let Expression</a></h2>
<pre><code class="language-nix">nix-repl&gt; let
            foo = &quot;foo val&quot;;
            bar = &quot;bar val, ${foo}&quot;;
          in
          { inherit foo bar; }
{ bar = &quot;bar val&quot;; foo = &quot;foo val&quot;; }
</code></pre>
<h2><a class="header" href="#with-expression" id="with-expression">With Expression</a></h2>
<pre><code class="language-nix">nix-repl&gt; let
            object = {
              foo = &quot;foo val&quot;;
              bar = &quot;bar val&quot;;
            };
          in
          [
            object.foo
            object.bar
          ]
[ &quot;foo val&quot; &quot;bar val&quot; ]
</code></pre>
<pre><code class="language-nix">nix-repl&gt; let
            object = {
              foo = &quot;foo val&quot;;
              bar = &quot;bar val&quot;;
            };
          in
          with object; [
            foo
            bar
          ]
[ &quot;foo val&quot; &quot;bar val&quot; ]
</code></pre>
<h2><a class="header" href="#function" id="function">Function</a></h2>
<pre><code class="language-nix">nix-repl&gt; greet = name: &quot;Hello, ${name}!&quot;

nix-repl&gt; greet &quot;Alice&quot;
&quot;Hello, Alice!&quot;

nix-repl&gt; greet &quot;Bob&quot;
&quot;Hello, Bob!&quot;
</code></pre>
<h2><a class="header" href="#curried-function" id="curried-function">Curried Function</a></h2>
<pre><code class="language-nix">nix-repl&gt; secret-greet = code: name:
            if code == &quot;secret&quot;
            then &quot;Hello, ${name}!&quot;
            else &quot;Nothing here&quot;

nix-repl&gt; secret-greet &quot;secret&quot; &quot;John&quot;
&quot;Hello, John!&quot;

nix-repl&gt; nothing = secret-greet &quot;wrong&quot;

nix-repl&gt; nothing &quot;Alice&quot;
&quot;Nothing here&quot;

nix-repl&gt; nothing &quot;Bob&quot;
&quot;Nothing here&quot;
</code></pre>
<h2><a class="header" href="#named-arguments" id="named-arguments">Named Arguments</a></h2>
<pre><code class="language-nix">nix-repl&gt; greet = { name, title }: &quot;Hello, ${title} ${name}&quot;

nix-repl&gt; greet { title = &quot;Ms.&quot;; name = &quot;Alice&quot;; }
&quot;Hello, Ms. Alice&quot;

nix-repl&gt; greet { name = &quot;Alice&quot;; }
error: anonymous function at (string):1:2 called without required argument 'title', at (string):1:1
</code></pre>
<h2><a class="header" href="#default-arguments" id="default-arguments">Default Arguments</a></h2>
<pre><code class="language-nix">nix-repl&gt; greet = { name ? &quot;Anonymous&quot;, title ? &quot;Ind.&quot; }: &quot;Hello, ${title} ${name}&quot;

nix-repl&gt; greet {}
&quot;Hello, Ind. Anonymous&quot;

nix-repl&gt; greet { name = &quot;Bob&quot;; }
&quot;Hello, Ind. Bob&quot;

nix-repl&gt; greet { title = &quot;Mr.&quot;; }
&quot;Hello, Mr. Anonymous&quot;
</code></pre>
<h2><a class="header" href="#lazy-evaluation" id="lazy-evaluation">Lazy Evaluation</a></h2>
<pre><code class="language-nix">nix-repl&gt; err = throw &quot;something went wrong&quot;

nix-repl&gt; err
error: something went wrong

nix-repl&gt; if true then 1 else err
1

nix-repl&gt; if false then 1 else err
error: something went wrong

nix-repl&gt; object = { foo = err; bar = &quot;bar val&quot;; }

nix-repl&gt; object.bar
&quot;bar val&quot;

nix-repl&gt; object.foo
error: something went wrong
</code></pre>
<h3><a class="header" href="#sequencing" id="sequencing">Sequencing</a></h3>
<pre><code class="language-nix">nix-repl&gt; builtins.seq err true
error: something went wrong
</code></pre>
<pre><code class="language-nix">nix-repl&gt; builtins.seq object true
true

nix-repl&gt; builtins.deepSeq object true
error: something went wrong
</code></pre>
<h1><a class="header" href="#file-management-in-nix" id="file-management-in-nix">File Management in Nix</a></h1>
<h2><a class="header" href="#string-to-file" id="string-to-file">String to File</a></h2>
<pre><code class="language-nix">nix-repl&gt; builtins.toFile &quot;hello.txt&quot; &quot;Hello World!&quot;
&quot;/nix/store/r4mvpxzh7rgrm4j831b2yi90zq64grqm-hello.txt&quot;
</code></pre>
<pre><code class="language-bash">$ cat /nix/store/r4mvpxzh7rgrm4j831b2yi90zq64grqm-hello.txt
Hello World!
</code></pre>
<h2><a class="header" href="#path" id="path">Path</a></h2>
<pre><code class="language-nix">nix-repl&gt; ./.
/path/to/nix-workshop

nix-repl&gt; ./code/01-getting-started
/path/to/nix-workshop/code/01-getting-started

nix-repl&gt; ./not-found
/path/to/nix-workshop/not-found
</code></pre>
<h2><a class="header" href="#path-concatenation" id="path-concatenation">Path Concatenation</a></h2>
<pre><code class="language-nix">nix-repl&gt; ./. + &quot;code/01-getting-started&quot;
/path/to/nix-workshop/code/01-getting-started
</code></pre>
<h2><a class="header" href="#read-file" id="read-file">Read File</a></h2>
<pre><code class="language-nix">nix-repl&gt; builtins.readFile ./code/03-nix-basics/03-files/hello.txt
&quot;Hello World!&quot;

nix-repl&gt; builtins.readFile /nix/store/r4mvpxzh7rgrm4j831b2yi90zq64grqm-hello.txt
&quot;Hello World!&quot;

nix-repl&gt; builtins.readFile (builtins.toFile &quot;hello&quot; &quot;Hello World!&quot;)
&quot;Hello World!&quot;
</code></pre>
<h2><a class="header" href="#path-1" id="path-1">Path</a></h2>
<pre><code class="language-nix">nix-repl&gt; builtins.path { path = ./.; }
&quot;/nix/store/s0c3cc8k6dy51zx9xicfprsl9r35zvf6-nix-workshop&quot;
</code></pre>
<pre><code class="language-nix">nix-repl&gt; &quot;${./.}&quot;
&quot;/nix/store/s0c3cc8k6dy51zx9xicfprsl9r35zvf6-nix-workshop&quot;
</code></pre>
<pre><code>$ ls /nix/store/s0c3cc8k6dy51zx9xicfprsl9r35zvf6-nix-workshop
01-getting-started  02-nix-commands ...
</code></pre>
<p>The exact address changes every time the directory is updated.</p>
<h2><a class="header" href="#named-path" id="named-path">Named Path</a></h2>
<pre><code class="language-nix">nix-repl&gt; workshop = builtins.path { path = ./.; name = &quot;first-scrive-workshop&quot;; }

nix-repl&gt; workshop
&quot;/nix/store/fp0lw035xhxqwgfqifxlb430lyw48r7m-first-scrive-workshop&quot;

nix-repl&gt; builtins.readFile (workshop + &quot;/code/03-nix-basics/03-files/hello.txt&quot;)
&quot;Hello World!&quot;
</code></pre>
<h2><a class="header" href="#content-addressible-path" id="content-addressible-path">Content Addressible Path</a></h2>
<p>The files <a href="03-nix-basics/03-files/hello.txt">hello.txt</a> and <a href="03-nix-basics/03-files/hello-2.txt">hello-2.txt</a>
both have the same content <code>&quot;Hello World!&quot;</code>, but they produce different artifacts
in the Nix store. i.e. Name of Nix artifacts depend on the name of the original
file / directory.</p>
<pre><code class="language-nix">nix-repl&gt; builtins.path { path = ./code/03-nix-basics/03-files/hello.txt; }
&quot;/nix/store/925f1jb1ajrypjbyq7rylwryqwizvhp0-hello.txt&quot;

nix-repl&gt; builtins.path { path = ./code/03-nix-basics/03-files/hello-2.txt; }
&quot;/nix/store/bghk1lsjcylfm05j00zj5j42lv09i79z-hello-2.txt&quot;
</code></pre>
<p>Solution: give a fixed name to path artifacts:</p>
<pre><code class="language-nix">nix-repl&gt; builtins.path {
            name = &quot;hello.txt&quot;;
            path = ./code/03-nix-basics/03-files/hello-2.txt;
          }
&quot;/nix/store/925f1jb1ajrypjbyq7rylwryqwizvhp0-hello.txt&quot;
</code></pre>
<h2><a class="header" href="#fetch-url" id="fetch-url">Fetch URL</a></h2>
<pre><code class="language-nix">nix-repl&gt; example = builtins.fetchurl &quot;https://scrive.com/robots.txt&quot;

nix-repl&gt; example
[0.0 MiB DL] downloading 'https://scrive.com/robots.txt'&quot;/nix/store/r98i29hkzwyykm984fpr4ldbai2r8lhj-robots.txt&quot;

nix-repl&gt; example
&quot;/nix/store/r98i29hkzwyykm984fpr4ldbai2r8lhj-robots.txt&quot;
</code></pre>
<pre><code class="language-bash">$ cat /nix/store/r98i29hkzwyykm984fpr4ldbai2r8lhj-robots.txt
User-agent: *
Sitemap: https://scrive.com/sitemap.xml
Disallow: /amnesia/
Disallow: /api/
</code></pre>
<p>URLs are only fetched once locally!</p>
<h2><a class="header" href="#fetch-tarball" id="fetch-tarball">Fetch Tarball</a></h2>
<pre><code class="language-bash">nix-repl&gt; nodejs-src = builtins.fetchTarball
            &quot;https://nodejs.org/dist/v14.15.0/node-v14.15.0-linux-x64.tar.xz&quot;
nix-repl&gt; nodejs-src
&quot;/nix/store/6wkj0blipzdqbsvwv03qy57n4l33scpw-source&quot;
</code></pre>
<pre><code class="language-bash">$ ls /nix/store/6wkj0blipzdqbsvwv03qy57n4l33scpw-source
bin  CHANGELOG.md  include  lib  LICENSE  README.md  share
</code></pre>
<h2><a class="header" href="#sha256-checksum" id="sha256-checksum">SHA256 Checksum</a></h2>
<p>Make sure that the content retrieved are the same for all users.</p>
<pre><code class="language-bash">nix-repl&gt; nodejs-src = builtins.fetchTarball {
            name = &quot;nodejs-src&quot;;
            url = &quot;https://nodejs.org/dist/v14.15.0/node-v14.15.0-linux-x64.tar.xz&quot;;
            sha256 = &quot;14jmakaxmlllyyprydc6826s7yk50ipvmwwrkzf6pdqis04g7a9v&quot;;
          }
nix-repl&gt; nodejs-src
&quot;/nix/store/6wkj0blipzdqbsvwv03qy57n4l33scpw-source&quot;
</code></pre>
<h1><a class="header" href="#import-modules" id="import-modules">Import Modules</a></h1>
<h2><a class="header" href="#import-nix-modules" id="import-nix-modules">Import Nix Modules</a></h2>
<p>We have the following files in
<a href="03-nix-basics/03-nix-basics/04-import">03-nix-basics/04-import</a>:</p>
<ul>
<li><a href="03-nix-basics/./04-import/foo.nix">foo.nix</a></li>
</ul>
<pre><code class="language-nix">&quot;foo val&quot;
</code></pre>
<ul>
<li><a href="03-nix-basics/./04-import/bar.nix">bar.nix</a></li>
</ul>
<pre><code class="language-nix">[ &quot;bar val 1&quot; &quot;bar val 2&quot; ]
</code></pre>
<ul>
<li><a href="03-nix-basics/./04-import/default.nix">default.nix</a></li>
</ul>
<pre><code class="language-nix">let
  foo = import ./foo.nix;
  bar = import ./bar.nix;
in
{ inherit foo bar; }
</code></pre>
<pre><code class="language-nix">nix-repl&gt; import ./code/03-nix-basics/04-import/foo.nix
&quot;foo val&quot;

nix-repl&gt; import ./code/03-nix-basics/04-import/bar.nix
[ &quot;bar val 1&quot; &quot;bar val 2&quot; ]

nix-repl&gt; import ./code/03-nix-basics/04-import
{ bar = [ ... ]; foo = &quot;foo val&quot;; }
</code></pre>
<h2><a class="header" href="#import-global-modules" id="import-global-modules">Import Global Modules</a></h2>
<pre><code class="language-nix">nix-repl&gt; nixpkgs = import &lt;nixpkgs&gt; {}

nix-repl&gt; nixpkgs.lib.stringLength &quot;hello&quot;
5
</code></pre>
<h2><a class="header" href="#import-tarball" id="import-tarball">Import Tarball</a></h2>
<p>Let's say we have the same <a href="03-nix-basics/./code/04-import/foo.nix">foo.nix</a> now available
as a <a href="https://gist.github.com/soareschen/d41e9b764018da4d2336644329c915e4">gist</a>.
We can import that file by asking Nix to fetch the tarball generated by GitHub:</p>
<pre><code class="language-nix">nix-repl&gt; gist = builtins.fetchTarball &quot;https://gist.github.com/soareschen/d41e9b764018da4d2336644329c915e4/archive/476c45eaba13e23316cdca781bda7ec68676397b.tar.gz&quot;

nix-repl&gt; foo = import (gist + &quot;/foo.nix&quot;)

nix-repl&gt; foo
&quot;foo val&quot;
</code></pre>
<h2><a class="header" href="#pin-tarball-version" id="pin-tarball-version">Pin Tarball Version</a></h2>
<p>We have tested our remote <code>foo.nix</code> hosted on GitHub Gist, expecting it
to have the same content as the local <a href="03-nix-basics/./04-import/foo.nix">foo.nix</a> we have.
But the gist can be updated, yet we want to ensure that the content remains
the same. This can be done by pinning the SHA256 checksum of <code>foo.nix</code> to
what we expect using <code>nix-prefetch-url</code>:</p>
<pre><code class="language-bash">$ nix-prefetch-url --type sha256 --unpack &quot;https://gist.github.com/soareschen/d41e9b764018da4d2336644329c915e4/archive/476c45eaba13e23316cdca781bda7ec68676397b.tar.gz&quot;
unpacking...
[0.0 MiB DL]
path is '/nix/store/vik2vk9ifbyps9pvhqa89px0c76cvaxz-476c45eaba13e23316cdca781bda7ec68676397b.tar.gz'
1ig5g6gvys26ka11z0wx08l72h8g5rr7p4fywk905sabdknf92yx
</code></pre>
<p>We can then copy the SHA256 checksum to make sure that the file content at the URL
never unexpectedly changes:</p>
<pre><code class="language-nix">nix-repl&gt; gist =  builtins.fetchTarball {
            url = &quot;https://gist.github.com/soareschen/d41e9b764018da4d2336644329c915e4/archive/476c45eaba13e23316cdca781bda7ec68676397b.tar.gz&quot;;
            sha256 = &quot;1ig5g6gvys26ka11z0wx08l72h8g5rr7p4fywk905sabdknf92yx&quot;;
          }
</code></pre>
<h2><a class="header" href="#pinning-nixpkgs" id="pinning-nixpkgs">Pinning Nixpkgs</a></h2>
<p>We can use the same approach to pin <code>nixpkgs</code> itself. By pinning <code>nixpkgs</code> to a
specific commit ID and SHA256 checksum, we can be sure that everyone that uses
our Nix module are using the exact version of <code>nixpkgs</code> that we have specified.</p>
<p>For instance, we can pin the <code>nixpkgs</code> version we use to commit
<a href="https://github.com/NixOS/nixpkgs/tree/c1e5f8723ceb684c8d501d4d4ae738fef704747e"><code>c1e5f8723ceb684c8d501d4d4ae738fef704747e</code></a>:</p>
<pre><code class="language-bash">$ nix-prefetch-url --type sha256 --unpack \
&gt;     &quot;https://github.com/NixOS/nixpkgs/archive/c1e5f8723ceb684c8d501d4d4ae738fef704747e.tar.gz&quot;
unpacking...
[19.6 MiB DL]
path is '/nix/store/7ik3kdki828cnva46vnis87ha6axjk7n-c1e5f8723ceb684c8d501d4d4ae738fef704747e.tar.gz'
02k3l9wnwpmq68xmmfy4wb2panqa1rs04p1mzh2kiwn0449hl86j
</code></pre>
<p>Now we can import our pinned <code>nixpkgs</code>:</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs-src =  builtins.fetchTarball {
            url = &quot;https://github.com/NixOS/nixpkgs/archive/c1e5f8723ceb684c8d501d4d4ae738fef704747e.tar.gz&quot;;
            sha256 = &quot;02k3l9wnwpmq68xmmfy4wb2panqa1rs04p1mzh2kiwn0449hl86j&quot;;
          }

nix-repl&gt; nixpkgs = import nixpkgs-src {}

nix-repl&gt; nixpkgs.lib.stringLength &quot;hello&quot;
5
</code></pre>
<p>Pinning nixpkgs is highly encouraged when developing Nix modules. Without
pinning, your user may run your modules on nixpkgs that has not been updated
for months, if they have installed Nix very long time ago.</p>
<p>We will go through in later chapter on how to use
<a href="https://github.com/nmattia/niv"><code>niv</code></a> to automate the management of
pinned remote Nix packages.</p>
<h1><a class="header" href="#nix-derivation-basics" id="nix-derivation-basics">Nix Derivation Basics</a></h1>
<p>First import a pinned version of <code>nixpkgs</code> so that we all get the same result:</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs-src = builtins.fetchTarball {
            url = &quot;https://github.com/NixOS/nixpkgs/archive/c1e5f8723ceb684c8d501d4d4ae738fef704747e.tar.gz&quot;;
            sha256 = &quot;02k3l9wnwpmq68xmmfy4wb2panqa1rs04p1mzh2kiwn0449hl86j&quot;;
          }

nix-repl&gt; nixpkgs = import nixpkgs-src {}
</code></pre>
<p>We use the pinned version of <code>nixpkgs</code> so that everyone following the
tutorial will get the exact same derivation.</p>
<h2><a class="header" href="#standard-derivation" id="standard-derivation">Standard Derivation</a></h2>
<pre><code class="language-nix">nix-repl&gt; hello-drv = nixpkgs.stdenv.mkDerivation {
            name = &quot;hello.txt&quot;;
            unpackPhase = &quot;true&quot;;
            installPhase = ''
              echo -n &quot;Hello World!&quot; &gt; $out
            '';
          }

nix-repl&gt; hello-drv
«derivation /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv»
</code></pre>
<pre><code class="language-bash">$ cat /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv
Derive([(&quot;out&quot;,&quot;/nix/store/f6qq9bwv0lxw5glzjmin1y1r1s3kangv-hello.txt&quot;,&quot;&quot;,&quot;&quot;)],...)

$ nix show-derivation /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv
{
  &quot;/nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt&quot;
      }
    },
    &quot;inputSrcs&quot;: [
      &quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;
    ],
    ...
  }
}
</code></pre>
<h2><a class="header" href="#building-derivation" id="building-derivation">Building Derivation</a></h2>
<p>We can now build our derivation:</p>
<pre><code class="language-bash">$ nix-build /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv
/nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt

$ cat /nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt
Hello World!
</code></pre>
<p>This may take some time to load on your computer, as Nix fetches the essential
build tools that are commonly needed to build Nix packages.</p>
<p>We can also build the derivation within Nix repl using the <code>:b</code> command:</p>
<pre><code class="language-nix">nix-repl&gt; :b hello-drv
[1 built, 0.0 MiB DL]

this derivation produced the following outputs:
  out -&gt; /nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt
</code></pre>
<h2><a class="header" href="#tracing-derivation" id="tracing-derivation">Tracing Derivation</a></h2>
<p>Our <code>hello-drv</code> produce the same output as <code>hello.txt</code> in previous chapter,
but produce different output in the Nix store. (previously we had
<code>/nix/store/925f1jb1ajrypjbyq7rylwryqwizvhp0-hello.txt</code>)</p>
<p>We can trace the dependencies of the derivation back to its source:</p>
<pre><code class="language-bash">$ nix-store --query --deriver /nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt
/nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv

$ nix-store --query --deriver /nix/store/925f1jb1ajrypjbyq7rylwryqwizvhp0-hello.txt
unknown-deriver
</code></pre>
<p>Our <code>hello.txt</code> built from <code>stdenv.mkDerivation</code> is built from a derivation
artifact <code>hello.txt.drv</code>, but our <code>hello.txt</code> created from <code>builtins.path</code>
has no deriver.
In other words, the Nix artifacts are different because they are produced from
different derivations.</p>
<p>We can further trace the dependencies of <code>hello.txt.drv</code>:</p>
<pre><code class="language-bash">$ nix-store -qR /nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv
/nix/store/01n3wxxw29wj2pkjqimmmjzv7pihzmd7-which-2.21.tar.gz.drv
/nix/store/03f77phmfdmsbfpcc6mspjfff3yc9fdj-setup-hook.sh
...
</code></pre>
<p>That's a lot of dependencies! Where are they being used? We will learn about it
in the next chapter.</p>
<h2><a class="header" href="#derivation-in-a-nix-file" id="derivation-in-a-nix-file">Derivation in a Nix File</a></h2>
<p>We save the same earlier derivation we defined inside a Nix file named
<a href="04-derivations/01-derivation-basics/hello.nix"><code>hello.nix</code></a>. Now we can build our derivation directly:</p>
<pre><code class="language-bash">$ nix-build 04-derivations/01-derivation-basics/hello.nix
/nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt
</code></pre>
<p>We can also get the derivation without building it using <code>nix-instantiate</code>:</p>
<pre><code class="language-bash">$ nix-instantiate 04-derivations/01-derivation-basics/hello.nix
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/ad6c51ia15p9arjmvvqkn9fys9sf1kdw-hello.txt.drv
</code></pre>
<p>Ignore the warning from <code>nix-instantiate</code>, as we don't care whether the derivation
is deleted during Nix garbage collection.</p>
<p>Notice that both the derivation and the build output have the same hash
as the earlier result we had in <code>nix repl</code>.</p>
<h2><a class="header" href="#caching-nix-build-artifacts" id="caching-nix-build-artifacts">Caching Nix Build Artifacts</a></h2>
<p>We create <a href="04-derivations/01-derivation-basics/hello-sleep.nix"><code>hello-sleep.nix</code></a> as a variant of
<code>hello.nix</code> which sleeps for 10 seconds in its <code>buildPhase</code>.
(We will go through how each phases work in the next chapter)
The 10 seconds sleep simulates the time taken to compile a program.
We can see what happens when we try to build the same Nix derivation
multiple times.</p>
<p>First, instantiating a derivation is not affected by the build time:</p>
<pre><code class="language-bash">$ time nix-instantiate 04-derivations/01-derivation-basics/hello-sleep.nix
/nix/store/58ngrpwgv6hl633a1iyjbmjqlbdqjw92-hello.txt.drv

real    0m0,217s
user    0m0,179s
sys     0m0,032s
</code></pre>
<p>The first time we build <code>hello-sleep.nix</code>, it is going to take about 10 seconds.
We can also see the logs we printed during the build phase is shown:</p>
<pre><code class="language-bash">$ time nix-build 04-derivations/01-derivation-basics/hello-sleep.nix
these derivations will be built:
  /nix/store/58ngrpwgv6hl633a1iyjbmjqlbdqjw92-hello.txt.drv
building '/nix/store/58ngrpwgv6hl633a1iyjbmjqlbdqjw92-hello.txt.drv'...
unpacking sources
patching sources
configuring
no configure script, doing nothing
building
Building hello world...
Finished building hello world!
installing
post-installation fixup
shrinking RPATHs of ELF executables and libraries in /nix/store/lm801yriwjj4298ry74hdv5j0rpkpacq-hello.txt
strip is /nix/store/bnjps68g8ax6abzvys2xpx12imrx8949-binutils-2.31.1/bin/strip
patching script interpreter paths in /nix/store/lm801yriwjj4298ry74hdv5j0rpkpacq-hello.txt
checking for references to /build/ in /nix/store/lm801yriwjj4298ry74hdv5j0rpkpacq-hello.txt...
/nix/store/lm801yriwjj4298ry74hdv5j0rpkpacq-hello.txt

real    0m12,202s
user    0m0,371s
sys     0m0,084s
</code></pre>
<p>But the next time we build <code>hello-sleep.nix</code>, it will take no time to build,
and there is no build output:</p>
<pre><code class="language-bash">$ time nix-build 03-nix-basics/05-derivation/hello-sleep.nix
/nix/store/lm801yriwjj4298ry74hdv5j0rpkpacq-hello.txt

real    0m0,310s
user    0m0,256s
sys     0m0,047s
</code></pre>
<p>Nix determines whether a derivation needs to be rebuilt based on the input
derivation. For our case, in both calls to <code>hello-sleep.nix</code>,
<code>nix-build</code> instantiates the derivation behind the scene at got
<code>/nix/store/k3cq3qn2cx7vmqjrzlc5wcbm3ci75yxy-hello.txt.drv</code>
as the result. So it determines that the result has previously already
been built, and reuse the same Nix artifact.</p>
<h2><a class="header" href="#derivation-as-file" id="derivation-as-file">Derivation as File</a></h2>
<p>With the duck-typing nature of Nix, derivations acts just like files in Nix.
We can actually treat the <code>hello-drv</code> we defined earlier as a file and
read from it:</p>
<pre><code class="language-nix">nix-repl&gt; builtins.readFile hello-drv
querying info about missing paths&quot;Hello World!&quot;
</code></pre>
<p>How does that works? Internally Nix lazily builds a
derivation when it is evaluated, and turn it into
a file path. We can verify that by using <code>builtins.toPath</code>:</p>
<pre><code class="language-nix">nix-repl&gt; builtins.toPath hello-drv
&quot;/nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt&quot;
</code></pre>
<p>With this property, we can also import derivations
from a Nix file, and then use it as if the derivation
has been built:</p>
<pre><code class="language-nix">nix-repl&gt; hello = import ./code/04-derivations/01-derivation-basics/hello.nix

nix-repl&gt; builtins.readFile hello
querying info about missing paths&quot;Hello World!&quot;
</code></pre>
<p>We can even use a derivation as a string. Nix automatically
builds the derivation when it is evaluated as a string:</p>
<pre><code class="language-nix">nix-repl&gt; &quot;path of hello: ${hello}&quot;
&quot;path of hello: /nix/store/z449wrqvwncs8clk7bsliabv1g1ci3n3-hello.txt&quot;
</code></pre>
<h1><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h1>
<p>Previously we have built toy derivations with dummy output. In practice,
Nix derivations are used for building programs, with build artifacts such as
compiled binaries being the derivation output.</p>
<p>We can demonstrate this property by &quot;building&quot; a greet program.
First we have to import a pinned version of nixpkgs as before.
To simplify the process we abstract it out into a <a href="04-derivations/../nixpkgs.nix">nixpkgs.nix</a>
at the root directory.</p>
<p>Now we build a greet program in <a href="04-derivations/./02-dependencies/greet.nix">greet.nix</a>:</p>
<pre><code class="language-nix">let
  nixpkgs = import ../../nixpkgs.nix;

  greet = nixpkgs.stdenv.mkDerivation {
    name = &quot;greet&quot;;
    unpackPhase = &quot;true&quot;;

    buildPhase = ''
      echo &quot;building greet...&quot;
      sleep 3
    '';

    installPhase = ''
      mkdir -p $out/bin

      cat &lt;&lt;'EOF' &gt; $out/bin/greet
      #!/usr/bin/env bash
      echo &quot;Hello, $1!&quot;
      EOF

      chmod +x $out/bin/greet
    '';
  };
in
greet
</code></pre>
<pre><code class="language-bash">$ nix-build code/04-derivations/02-dependencies/greet.nix
these derivations will be built:
  /nix/store/97lmyym0isl0ism7pfnv1b0ls4cahpi8-greet.drv
building '/nix/store/97lmyym0isl0ism7pfnv1b0ls4cahpi8-greet.drv'...
unpacking sources
patching sources
configuring
no configure script, doing nothing
building
building greet...
installing
post-installation fixup
shrinking RPATHs of ELF executables and libraries in /nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet
strip is /nix/store/bnjps68g8ax6abzvys2xpx12imrx8949-binutils-2.31.1/bin/strip
stripping (with command strip and flags -S) in /nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin
patching script interpreter paths in /nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet
/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin/greet: interpreter directive changed from &quot;/usr/bin/env bash&quot; to &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;
checking for references to /build/ in /nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet...
/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet
</code></pre>
<p>Now we can run greet:</p>
<pre><code class="language-bash">$ result/bin/greet John
Hello, John!
</code></pre>
<p>Let's try to see what's inside the produced <code>greet</code> script:</p>
<pre><code class="language-bash">$ cat result/bin/greet
#!/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
echo &quot;Hello, $1!&quot;
</code></pre>
<p>The shebang to the bash shell has been modified to pin to the Nix version of Bash.</p>
<h2><a class="header" href="#upper-greet" id="upper-greet">Upper Greet</a></h2>
<p>Our greet program can now be used as a dependency to other derivations.
Let's create an <code>upper-greet</code> derivation that convert any greet result to
upper case.</p>
<p><a href="04-derivations/./02-dependencies/upper-greet.nix">upper-greet.nix</a>:</p>
<pre><code class="language-nix">let
  nixpkgs = import ../../nixpkgs.nix;

  inherit (nixpkgs) coreutils;

  greet = import ./greet.nix;
in
nixpkgs.stdenv.mkDerivation {
  name = &quot;upper-greet&quot;;

  unpackPhase = &quot;true&quot;;

  buildPhase = ''
    echo &quot;building upper-greet...&quot;
    sleep 3
  '';

  installPhase = ''
    mkdir -p $out/bin

    cat &lt;&lt;'EOF' &gt; $out/bin/upper-greet
    #!/usr/bin/env bash
    ${greet}/bin/greet &quot;$@&quot; | ${coreutils}/bin/tr [a-z] [A-Z]
    EOF

    chmod +x $out/bin/upper-greet
  '';
}
</code></pre>
<h3><a class="header" href="#show-derivation" id="show-derivation">Show Derivation</a></h3>
<p>First we instantiate <code>upper-greet.drv</code> without building it yet:</p>
<pre><code class="language-bash">drv=$(nix-instantiate 04-derivations/02-dependencies/upper-greet.nix)
</code></pre>
<p>We can use <code>nix show-derivation</code> to find out the dependency graph of the
derivation of <code>upper-greet</code>:</p>
<pre><code class="language-bash">$ nix show-derivation $drv
{
  &quot;/nix/store/n61g8616l7g7zv32q52yrzmzr850mjp0-upper-greet.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet&quot;
      }
    },
    &quot;inputSrcs&quot;: [
      &quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;
    ],
    &quot;inputDrvs&quot;: {
      &quot;/nix/store/7gby8zic1p851ap63q1vdpwy7z1db85c-coreutils-8.32.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/97lmyym0isl0ism7pfnv1b0ls4cahpi8-greet.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/l54djrh1n7d8zdfn26w7v6zjh5wp7faa-bash-4.4-p23.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/x9why09hwx2pcnmw0fw7hhh1511hyskl-stdenv-linux.drv&quot;: [
        &quot;out&quot;
      ]
    },
    ...
    &quot;env&quot;: {
      &quot;buildInputs&quot;: &quot;&quot;,
      &quot;buildPhase&quot;: &quot;echo \&quot;building upper-greet...\&quot;\nsleep 3\n&quot;,
      &quot;builder&quot;: &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;,
      ...
      &quot;installPhase&quot;: &quot;mkdir -p $out/bin\n\ncat &lt;&lt;'EOF' &gt; $out/bin/upper-greet\n#!/usr/bin/env bash\n/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin/greet \&quot;$@\&quot; | /nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/tr [a-z] [A-Z]\nEOF\n\nchmod +x $out/bin/upper-greet\n&quot;,
      &quot;name&quot;: &quot;upper-greet&quot;,
...
</code></pre>
<p>We can see that <code>greet.drv</code> is included as one of <code>inputDrvs</code>. This means that when
<code>upper-greet.drv</code> is being built, <code>greet.drv</code> will have to be built first.</p>
<p>The output path of <code>upper-greet.drv</code> is listed in <code>outputs</code>. This shows that
the output hash of a derivation is fixed, regardless of the content of the
build result.</p>
<p>This is also why the output path of <code>greet.drv</code> is used directly in <code>env.installPhase</code>
of <code>upper-greet.drv</code>, even for the case when <code>greet.drv</code> has not been built.</p>
<h3><a class="header" href="#build-derivation" id="build-derivation">Build Derivation</a></h3>
<pre><code class="language-bash">$ nix-build 04-derivations/02-dependencies/upper-greet.nix
these derivations will be built:
  /nix/store/n61g8616l7g7zv32q52yrzmzr850mjp0-upper-greet.drv
building '/nix/store/n61g8616l7g7zv32q52yrzmzr850mjp0-upper-greet.drv'...
unpacking sources
patching sources
configuring
no configure script, doing nothing
building
building upper-greet...
installing
post-installation fixup
shrinking RPATHs of ELF executables and libraries in /nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet
strip is /nix/store/bnjps68g8ax6abzvys2xpx12imrx8949-binutils-2.31.1/bin/strip
stripping (with command strip and flags -S) in /nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet/bin
patching script interpreter paths in /nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet
/nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet/bin/upper-greet: interpreter directive changed from &quot;/usr/bin/env bash&quot; to &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;
checking for references to /build/ in /nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet...
/nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet
</code></pre>
<p>As expected, the greet results are turned into upper case.</p>
<pre><code class="language-bash">$ result/bin/upper-greet John
HELLO, JOHN!
</code></pre>
<p>The absolute paths to <code>greet</code> and <code>coreutils</code> are extended:</p>
<pre><code class="language-bash">$ cat result/bin/upper-greet
#!/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin/greet &quot;$@&quot; | /nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/tr [a-z] [A-Z]
</code></pre>
<h3><a class="header" href="#runtime-dependency" id="runtime-dependency">Runtime Dependency</a></h3>
<p>If we query the references of the <code>upper-greet</code> output (not the derivation),
we can see that <code>greet</code> is still a <em>runtime</em> dependency of <code>upper-greet</code>.</p>
<pre><code class="language-bash">$ nix-store --query --references /nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet
/nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32
/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23
/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet
</code></pre>
<p>We can use <code>nix why-depends</code> to find out why Nix thinks <code>greet</code> is a runtime
dependency to <code>upper-greet</code>:</p>
<pre><code class="language-bash">$ nix why-depends /nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet /nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet
/nix/store/dj2vp64gbja0bp65lngrw9q4lrm1a8r3-upper-greet
╚═══bin/upper-greet: …ash-4.4-p23/bin/bash./nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin/greet &quot;$@&quot; | /nix/sto…
    =&gt; /nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet
</code></pre>
<h1><a class="header" href="#fibonacci" id="fibonacci">Fibonacci</a></h1>
<p>Nix dependencies can be nested arbitrarily deep. We can demonstrate that by building
a fibonacci Nix derivation with the following behavior:</p>
<ul>
<li>Answers are produced in <code>$out/answer</code>.</li>
<li>Each build takes 3 seconds to produce the answer.</li>
<li><code>fib(0)</code> is 0, and <code>fib(1)</code> is 1.</li>
<li><code>fib(n)</code> depends on the answers from <code>fib(n-1)</code> and <code>fib(n-2)</code>.</li>
<li>The builds are prefixed with a name, so that we can force Nix to re-evaluate
the whole sequence by changing the name.</li>
</ul>
<p><a href="04-derivations/./03-fibonacci/fib.nix">fib.nix</a>:</p>
<pre><code class="language-nix">let
  nixpkgs = import ../../nixpkgs.nix;

  inherit (nixpkgs) stdenv;

  prefixed-fib = prefix:
    let fib = n:
      assert builtins.isInt n;
      assert n &gt;= 0;
      let
        n-str = builtins.toString n;
      in
        if n == 0 || n == 1
        then
          stdenv.mkDerivation {
            name = &quot;${prefix}-fib-${n-str}&quot;;
            unpackPhase = &quot;true&quot;;

            buildPhase = ''
              echo &quot;Producing base case fib(${n-str})...&quot;
              sleep 3
              echo &quot;The answer to fib(${n-str}) is ${n-str}&quot;
            '';

            installPhase = ''
              mkdir -p $out
              echo &quot;${n-str}&quot; &gt; $out/answer
            '';
          }
        else
          let
            fib-1 = fib (n - 1);
            fib-2 = fib (n - 2);

            n-1-str = builtins.toString (n - 1);
            n-2-str = builtins.toString (n - 2);
          in
          stdenv.mkDerivation {
            name = &quot;${prefix}-fib-${n-str}&quot;;
            unpackPhase = &quot;true&quot;;

            buildPhase = ''
              fib_1=$(cat ${fib-1}/answer)
              fib_2=$(cat ${fib-2}/answer)

              echo &quot;Calculating the answer of fib(${n-str})..&quot;
              echo &quot;Given fib(${n-1-str}) = $fib_1,&quot;
              echo &quot;and given fib(${n-2-str}) = $fib_2..&quot;

              sleep 3

              answer=$(( $fib_1 + $fib_2 ))
              echo &quot;The answer to fib(${n-str}) is $answer&quot;
            '';

            installPhase = ''
              mkdir -p $out
              echo &quot;$answer&quot; &gt; $out/answer
            '';
          }
    ;
  in fib;
in
prefixed-fib
</code></pre>
<p>To make sure we build the fibonacci sequence from scratch each time, we can use
<code>$(date +%s)</code> with the Unix timestamp as the prefix to our builds.</p>
<p>Let's try <code>fib(0)</code> and <code>fib(1)</code>:</p>
<pre><code class="language-bash">$ time nix-build -E &quot;import ./code/04-derivations/03-fibonacci/fib.nix \&quot;$(date +%s)\&quot; 0&quot;
these derivations will be built:
  /nix/store/yyy5fz5rsws6a812c9xc5ps1hwh9lm98-1605561354-fib-0.drv
building '/nix/store/yyy5fz5rsws6a812c9xc5ps1hwh9lm98-1605561354-fib-0.drv'...
...
no configure script, doing nothing
building
Producing base case fib(0)...
The answer to fib(0) is 0
...
checking for references to /build/ in /nix/store/9kvw6x88l9nx42mvrgzif60a72h66fqz-1605561354-fib-0...
/nix/store/9kvw6x88l9nx42mvrgzif60a72h66fqz-1605561354-fib-0

real    0m4,763s
user    0m0,476s
sys     0m0,130s
</code></pre>
<pre><code class="language-bash">$ time nix-build -E &quot;import ./code/04-derivations/03-fibonacci/fib.nix \&quot;$(date +%s)\&quot; 1&quot;
these derivations will be built:
  /nix/store/qs2pc54dmd21xlhlqgzwmgfj98y1kr8n-1605561412-fib-1.drv
building '/nix/store/qs2pc54dmd21xlhlqgzwmgfj98y1kr8n-1605561412-fib-1.drv'...
...
Producing base case fib(1)...
The answer to fib(1) is 1
...
checking for references to /build/ in /nix/store/426cpqvvr7lbg92hywmbw7552vggpway-1605561412-fib-1...
/nix/store/426cpqvvr7lbg92hywmbw7552vggpway-1605561412-fib-1

real    0m5,279s
user    0m0,415s
sys     0m0,102s
</code></pre>
<p>So both <code>fib(0)</code> and <code>fib(1)</code> takes roughly 4~5 seconds to build.</p>
<p>Let's try <code>fib(2)</code>:</p>
<pre><code class="language-bash">$ time nix-build -E &quot;import ./code/04-derivations/03-fibonacci/fib.nix \&quot;$(date +%s)\&quot; 2&quot;
these derivations will be built:
  /nix/store/r8n1v9ifk0q6mf75j35scn3s2dwa03j7-1605561535-fib-1.drv
  /nix/store/xxrzkbsnq1jpp4s5fdkpklxr3fbc0aq6-1605561535-fib-0.drv
  /nix/store/1bgy17jbakr9yn1yz0bnwhnnz1y1xsdc-1605561535-fib-2.drv
building '/nix/store/xxrzkbsnq1jpp4s5fdkpklxr3fbc0aq6-1605561535-fib-0.drv'...
...
Producing base case fib(0)...
The answer to fib(0) is 0
...
checking for references to /build/ in /nix/store/8k74irn8w8rzpccd30wdn8589nq0wdv5-1605561535-fib-0...
building '/nix/store/r8n1v9ifk0q6mf75j35scn3s2dwa03j7-1605561535-fib-1.drv'...
...
Producing base case fib(1)...
The answer to fib(1) is 1
...
checking for references to /build/ in /nix/store/p716qrpmyi4649k2njfy7gb97ksyi5y3-1605561535-fib-1...
building '/nix/store/1bgy17jbakr9yn1yz0bnwhnnz1y1xsdc-1605561535-fib-2.drv'...
...
Calculating the answer of fib(2)..
Given fib(1) = 1,
and given fib(0) = 0..
The answer to fib(2) is 1
...
checking for references to /build/ in /nix/store/qnaad56wgknlgki9r3kpmr4fhc7x8vxv-1605561535-fib-2...
/nix/store/qnaad56wgknlgki9r3kpmr4fhc7x8vxv-1605561535-fib-2

real    0m12,599s
user    0m0,658s
sys     0m0,198s
</code></pre>
<p>So building <code>fib(2)</code> causes <code>fib(1)</code> and <code>fib(0)</code> to also be built.</p>
<p>With this going on, if we are going to build <code>fib(5)</code>, then in total it is going to take a lot of time!
but if we have built <code>fib(4)</code> already, then building <code>fib(5)</code> will be very fast.</p>
<p>Let's fix our prefix to see Nix cache in effect:</p>
<pre><code class="language-bash">$ prefix=$(date +%s)
$ time nix-build -E &quot;import ./code/04-derivations/03-fibonacci/fib.nix \&quot;$prefix\&quot; 4&quot;
these derivations will be built:
  /nix/store/gz9bgzmna8v7pw5giclfhrk81dp1z0rw-1605561962-fib-1.drv
  /nix/store/y2waqw60jqawallz4q3r64iwrrihnd1p-1605561962-fib-0.drv
  /nix/store/nwj4bmrqgfv1fkvhh00bl2v03c3zqpy1-1605561962-fib-2.drv
  /nix/store/17d2r2dd52qvmfa5k3dm9gkl1k09wdb8-1605561962-fib-3.drv
  /nix/store/w4w4la01p9a2i8mlg6fm15il6vmgcqzl-1605561962-fib-4.drv
building '/nix/store/y2waqw60jqawallz4q3r64iwrrihnd1p-1605561962-fib-0.drv'...
...
Calculating the answer of fib(4)..
Given fib(3) = 2,
and given fib(2) = 1..
The answer to fib(4) is 3
...
checking for references to /build/ in /nix/store/c26q5vs8vdfr268nqgamjk8bcypf8b7r-1605561962-fib-4...
/nix/store/c26q5vs8vdfr268nqgamjk8bcypf8b7r-1605561962-fib-4

real    0m19,486s
user    0m0,910s
sys     0m0,253s
</code></pre>
<p>Now run <code>fib(5)</code>:</p>
<pre><code class="language-bash">$ time nix-build -E &quot;import ./code/04-derivations/03-fibonacci/fib.nix \&quot;$prefix\&quot; 5&quot;
these derivations will be built:
  /nix/store/nyb25403l4m5n69y3djlffsyzvpwyv6g-1605561962-fib-5.drv
building '/nix/store/nyb25403l4m5n69y3djlffsyzvpwyv6g-1605561962-fib-5.drv'...
unpacking sources
patching sources
configuring
no configure script, doing nothing
building
Calculating the answer of fib(5)..
Given fib(4) = 3,
and given fib(3) = 2..
The answer to fib(5) is 5
installing
post-installation fixup
shrinking RPATHs of ELF executables and libraries in /nix/store/p4iq9jaiid469ycgjm5v3ks3w0v35spi-1605561962-fib-5
strip is /nix/store/bnjps68g8ax6abzvys2xpx12imrx8949-binutils-2.31.1/bin/strip
patching script interpreter paths in /nix/store/p4iq9jaiid469ycgjm5v3ks3w0v35spi-1605561962-fib-5
checking for references to /build/ in /nix/store/p4iq9jaiid469ycgjm5v3ks3w0v35spi-1605561962-fib-5...
/nix/store/p4iq9jaiid469ycgjm5v3ks3w0v35spi-1605561962-fib-5

real    0m7,916s
user    0m0,461s
sys     0m0,151s
</code></pre>
<p>Now only <code>fib-5.drv</code> needs to be built.</p>
<h2><a class="header" href="#lazy-evaluation-1" id="lazy-evaluation-1">Lazy Evaluation</a></h2>
<p>A derivation like <code>fib(10)</code> is going to take a long time to build. So we don't really want to build
it unless we actually need it. In fact, we also wouldn't want to build <code>fib(0)</code> through <code>fib(10)</code>
unless they are actually needed.</p>
<p>With Nix's lazy evaluation strategy, we in fact get the laziness property that none of
the fibonacci derivations are going to be built unless they are needed:</p>
<pre><code class="language-bash">$ time nix-instantiate -E &quot;import ./code/04-derivations/03-fibonacci/fib.nix \&quot;$(date +%s)\&quot; 10&quot;
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
/nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv

real    0m0,235s
user    0m0,182s
sys     0m0,038s
</code></pre>
<p>We can see that while <code>fib(10)</code> has <code>fib(0)</code> through <code>fib(9)</code> as its dependencies,
but they are not being built just yet.</p>
<pre><code class="language-bash">$ nix-store -qR /nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv | grep fib
/nix/store/31xdxhxynqndaiym043bjjky0l229vlg-1605562192-fib-1.drv
/nix/store/r4wkf6774ahva1zchk77kpvjf14xigrl-1605562192-fib-0.drv
/nix/store/8agah8vidgxi6yp9ki066yimfr16kigg-1605562192-fib-2.drv
/nix/store/ka3glx20pgzkvgan88xl87xki51y5pmi-1605562192-fib-3.drv
/nix/store/v5zra6kayssdg04n7xpjljqa1q5jjyqn-1605562192-fib-4.drv
/nix/store/1cqwdhnk8f55lxlajmjw6rzq2lq12x5l-1605562192-fib-5.drv
/nix/store/qrbrgdv16f7mc2xfalrgmypfz6c7yljq-1605562192-fib-6.drv
/nix/store/p5chc4l9mjqw5871lkd6har4hyjp55fj-1605562192-fib-7.drv
/nix/store/gn9hp9jcsfclrsdx6qlvjd051w4rsx8b-1605562192-fib-8.drv
/nix/store/6av3vlibm4knm4m3djcrfrhhb6jck3zx-1605562192-fib-9.drv
/nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv
</code></pre>
<h3><a class="header" href="#input-derivations" id="input-derivations">Input Derivations</a></h3>
<p>If we inspect the derivation, the derivations <code>fib-9.drv</code> and <code>fib-8.drv</code>
are listed as one of the input derivations:</p>
<pre><code class="language-bash">$ nix show-derivation /nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv
{
  &quot;/nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/g7415lrzl6b43vnw58dgkxg5nzbjplp0-1605562192-fib-10&quot;
      }
    },
    &quot;inputSrcs&quot;: [
      &quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;
    ],
    &quot;inputDrvs&quot;: {
      &quot;/nix/store/6av3vlibm4knm4m3djcrfrhhb6jck3zx-1605562192-fib-9.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/gn9hp9jcsfclrsdx6qlvjd051w4rsx8b-1605562192-fib-8.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/l54djrh1n7d8zdfn26w7v6zjh5wp7faa-bash-4.4-p23.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/x9why09hwx2pcnmw0fw7hhh1511hyskl-stdenv-linux.drv&quot;: [
        &quot;out&quot;
      ]
    },
    ...
    &quot;env&quot;: {
      &quot;buildInputs&quot;: &quot;&quot;,
      &quot;buildPhase&quot;: &quot;fib_1=$(cat /nix/store/zr1ziy94ig8isdg0gdliz0sm59abh2l1-1605562192-fib-9/answer)\nfib_2=$(cat /nix/store/zvivby98nbjlb6pszp6qla4v1r6zwj82
-1605562192-fib-8/answer)\n\necho \&quot;Calculating the answer of fib(10)..\&quot;\necho \&quot;Given fib(9) = $fib_1,\&quot;\necho \&quot;and given fib(8) = $fib_2..\&quot;\n\nsleep 3\n\
nanswer=$(( $fib_1 + $fib_2 ))\necho \&quot;The answer to fib(10) is $answer\&quot;\n&quot;,
...
</code></pre>
<h3><a class="header" href="#building-actual-derivation" id="building-actual-derivation">Building Actual Derivation</a></h3>
<p>We can build them later on when <code>nix-build</code> is actually called, or we can get the cached result
from else where before building them.</p>
<pre><code class="language-bash">$ time nix-build /nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv
these derivations will be built:
  /nix/store/31xdxhxynqndaiym043bjjky0l229vlg-1605562192-fib-1.drv
  /nix/store/r4wkf6774ahva1zchk77kpvjf14xigrl-1605562192-fib-0.drv
  /nix/store/8agah8vidgxi6yp9ki066yimfr16kigg-1605562192-fib-2.drv
  /nix/store/ka3glx20pgzkvgan88xl87xki51y5pmi-1605562192-fib-3.drv
  /nix/store/v5zra6kayssdg04n7xpjljqa1q5jjyqn-1605562192-fib-4.drv
  /nix/store/1cqwdhnk8f55lxlajmjw6rzq2lq12x5l-1605562192-fib-5.drv
  /nix/store/qrbrgdv16f7mc2xfalrgmypfz6c7yljq-1605562192-fib-6.drv
  /nix/store/p5chc4l9mjqw5871lkd6har4hyjp55fj-1605562192-fib-7.drv
  /nix/store/gn9hp9jcsfclrsdx6qlvjd051w4rsx8b-1605562192-fib-8.drv
  /nix/store/6av3vlibm4knm4m3djcrfrhhb6jck3zx-1605562192-fib-9.drv
  /nix/store/dwjxm9rqxfbhf4m8nbg5wzddx1j4rcpl-1605562192-fib-10.drv
building '/nix/store/r4wkf6774ahva1zchk77kpvjf14xigrl-1605562192-fib-0.drv'...
...
Calculating the answer of fib(10)..
Given fib(9) = 34,
and given fib(8) = 21..
The answer to fib(10) is 55
...
checking for references to /build/ in /nix/store/g7415lrzl6b43vnw58dgkxg5nzbjplp0-1605562192-fib-10...
/nix/store/g7415lrzl6b43vnw58dgkxg5nzbjplp0-1605562192-fib-10

real    0m39,818s
user    0m1,260s
sys     0m0,413s
</code></pre>
<h2><a class="header" href="#evaluation-time-dependencies" id="evaluation-time-dependencies">Evaluation-Time Dependencies</a></h2>
<p>In our original <code>fib.nix</code>, the build output of earlier fibonacci
numbers are used during the build phase of the current derivation.
But if we somehow uses the earlier fibonacci numbers to build
the derviation itself, Nix would behave quite differently.</p>
<p><a href="04-derivations/./code/03-fibonacci/fib-serialized.nix"><code>fib-serialized.nix</code></a>:</p>
<pre><code class="language-nix">let
  fib-1 = fib (n - 1);
  fib-2 = fib (n - 2);

  n-1-str = builtins.toString (n - 1);
  n-2-str = builtins.toString (n - 2);

  fib-1-answer = nixpkgs.lib.removeSuffix &quot;\n&quot;
    (builtins.readFile &quot;${fib-1}/answer&quot;);
  fib-2-answer = nixpkgs.lib.removeSuffix &quot;\n&quot;
    (builtins.readFile &quot;${fib-2}/answer&quot;);
in
stdenv.mkDerivation {
  name = &quot;${prefix}-fib-${n-str}&quot;;
  unpackPhase = &quot;true&quot;;

  buildPhase = ''
    echo &quot;Calculating the answer of fib(${n-str})..&quot;
    echo &quot;Given fib(${n-1-str}) = ${fib-1-answer},&quot;
    echo &quot;and given fib(${n-2-str}) = ${fib-2-answer}..&quot;

    sleep 3

    answer=$(( ${fib-1-answer} + ${fib-2-answer} ))
    echo &quot;The answer to fib(${n-str}) is $answer&quot;
  '';
  ...
}
</code></pre>
<p>Let's try to instantiate the serialized version of <code>fib(4)</code>:</p>
<pre><code class="language-bash">$ time nix-instantiate -E &quot;import ./code/04-derivations/03-fibonacci/fib-serialized.nix \&quot;$(date +%s)\&quot; 4&quot;
building '/nix/store/97h18adc1358s8ri9mjzmnbvbbsj7p0a-1606145205-fib-1.drv'...
...
Producing base case fib(1)...
The answer to fib(1) is 1
...
building '/nix/store/fyizpk51qr2k6pm6v2pbqynfqf8ws68p-1606145205-fib-0.drv'...
...
Producing base case fib(0)...
The answer to fib(0) is 0
...
building '/nix/store/8qglzk0vq984mx65f3993rqjpipc3q9j-1606145205-fib-2.drv'...
...
Calculating the answer of fib(2)..
Given fib(1) = 1,
and given fib(0) = 0..
The answer to fib(2) is 1
...
building '/nix/store/4p8xy858gwc348576h6rz39a3l7wk64l-1606145205-fib-3.drv'...
...
Calculating the answer of fib(3)..
Given fib(2) = 1,
and given fib(1) = 1..
The answer to fib(3) is 2
...
/nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv

real    0m20,016s
user    0m1,221s
sys     0m0,261s
</code></pre>
<p>What happened here? <code>fib(0)</code> to <code>fib(3)</code> are built even though we are just
instantiating <code>fib(4)</code>.</p>
<h3><a class="header" href="#inspecting-input-derivation" id="inspecting-input-derivation">Inspecting Input Derivation</a></h3>
<p>Showing the derivation of <code>fib-4.drv</code> gives us a better idea:</p>
<pre><code class="language-bash">$ nix show-derivation /nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv
{
  &quot;/nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/fgq0j5mlqpy99mfdfc3v4bvbd6wr2slg-1606145205-fib-4&quot;
      }
    },
    ...
    &quot;inputDrvs&quot;: {
      &quot;/nix/store/l54djrh1n7d8zdfn26w7v6zjh5wp7faa-bash-4.4-p23.drv&quot;: [
        &quot;out&quot;
      ],
      &quot;/nix/store/x9why09hwx2pcnmw0fw7hhh1511hyskl-stdenv-linux.drv&quot;: [
        &quot;out&quot;
      ]
    },
    &quot;env&quot;: {
      &quot;buildInputs&quot;: &quot;&quot;,
      &quot;buildPhase&quot;: &quot;echo \&quot;Calculating the answer of fib(4)..\&quot;\necho \&quot;Given fib(3) = 2,\&quot;\necho \&quot;and given fib(2) = 1..\&quot;\n\nsleep 3\n\nanswer=$(( 2 + 1 ))\necho \&quot;The answer to fib(4) is $answer\&quot;\n&quot;,
  ...
</code></pre>
<p>Thanks to <code>builtins.readFile</code>, the results for <code>fib(3)</code> and <code>fib(2)</code> have in fact
been calculated and inlined inside the the derivation itself. They are no longer
listed in the input derivation.</p>
<h2><a class="header" href="#caching-problem-of-evaluation-time-dependencies" id="caching-problem-of-evaluation-time-dependencies">Caching Problem of Evaluation-Time Dependencies</a></h2>
<p>In fact, <code>fib(3)</code> and <code>fib(2)</code> are not even shown as dependencies in <code>fib(4)</code> anymore:</p>
<pre><code class="language-bash">$ nix-store -qR --include-outputs /nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv | grep fib
/nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv
/nix/store/fgq0j5mlqpy99mfdfc3v4bvbd6wr2slg-1606145205-fib-4
</code></pre>
<p>This has a consequence in caching Nix dependencies. Not knowing <code>fib(0)</code> to
<code>fib(3)</code> are actually input to <code>fib(4)</code>, it would be difficult to properly
cache these dependencies to Cachix.</p>
<h2><a class="header" href="#import-from-derivation" id="import-from-derivation">Import From Derivation</a></h2>
<p>Evaluation-time dependencies can also occur if we import a <code>.nix</code> file from a derivation.
Since Nix has to read the file content to be able to import the <code>.nix</code> file, the
derivation has to be built at evaluation time. This is more commonly known as
<a href="https://nixos.wiki/wiki/Import_From_Derivation">Import From Derivation</a>, or
IFD in short.</p>
<p>IFD should be avoided if possible. However as we will see in later chapters,
there are valid use cases that can only be solved using IFD.</p>
<h3><a class="header" href="#non-lazy-build" id="non-lazy-build">Non-Lazy Build</a></h3>
<p>If we build <code>fib(4)</code> now, indeed only <code>fib(4)</code> itself is being built.</p>
<pre><code class="language-bash">$ nix-build /nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv
these derivations will be built:
  /nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv
building '/nix/store/c29ap9ljazs7k0jx687hnm3s0rgsz2vm-1606145205-fib-4.drv'...
...
Calculating the answer of fib(4)..
Given fib(3) = 2,
and given fib(2) = 1..
The answer to fib(4) is 3
...
/nix/store/fgq0j5mlqpy99mfdfc3v4bvbd6wr2slg-1606145205-fib-4
</code></pre>
<p>The same effect can also happen if we import <code>.nix</code> files from derivation outputs.</p>
<p>Lesson learnt: parallelization in Nix can still be tricky. Try your best to
include dependencies as input derivations, and lazily refer to the built output
of dependencies only during build time.</p>
<h1><a class="header" href="#raw-derivation" id="raw-derivation">Raw Derivation</a></h1>
<p>We have previously used <code>stdenv.mkDerivation</code> to define toy derivations without
looking into how derivations work. Here we will go deeper into Nix derivations,
starting with the most basic derivation construct, <code>builtins.derivation</code>.</p>
<p>From the repl, we can see that <code>builtins.derivation</code> is a function:</p>
<pre><code class="language-nix">nix-repl&gt; builtins.derivation
«lambda @ /nix/store/qxayqjmlpqnmwg5yfsjjayw220ls8i2r-nix-2.3.8/share/nix/corepkgs/derivation.nix:4:1»
</code></pre>
<p>Since <code>builtins.derviation</code> is more primitive as compared to <code>stdenv.mkDerivation</code>,
the way we can build a derivation is also more involved:</p>
<pre><code class="language-nix">nix-repl&gt; builtins.derivation {
            name = &quot;hello&quot;;
            system = builtins.currentSystem;
            builder = &quot;${nixpkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot;
              ''
              echo &quot;Hello World!&quot; &gt; $out
              ''
            ];
          }
«derivation /nix/store/hbsv13kn5imfri16f6g2l5c2jy6dfmxl-hello.drv»
</code></pre>
<h3><a class="header" href="#system" id="system">System</a></h3>
<p>First we have to supply a <code>system</code> attribute, which we set it to
the current OS we are running on. It is most common to have the
system values as <code>&quot;x86_64-linux&quot;</code> or <code>&quot;x86_64-darwin&quot;</code>.</p>
<pre><code class="language-nix">nix-repl&gt; builtins.currentSystem
&quot;x86_64-linux&quot;
</code></pre>
<p>The <code>system</code> attribute is required because Nix supports cross compilation.
So we can also define derivations that are built on different platforms
than the one we are on.</p>
<h3><a class="header" href="#builder" id="builder">Builder</a></h3>
<p>The <code>builder</code> attribute expects a file path to an executable script that is
called when the derivation is built. To keep things simple, we use the bash
shell from <code>nixpkgs.bash</code> as the builder program.</p>
<p>The <code>args</code> attribute is used to specify the command line line arguments
passed to the builder program. Since bash itself do not know how to
build the program we want, we pass the command string using <code>-c</code>
to execute the bash script <code>echo &quot;Hello World!&quot; &gt; $out</code></p>
<p>Now we can try to build the derivation and see that it works:</p>
<pre><code class="language-bash">$ nix-build /nix/store/hbsv13kn5imfri16f6g2l5c2jy6dfmxl-hello.drv
these derivations will be built:
  /nix/store/hbsv13kn5imfri16f6g2l5c2jy6dfmxl-hello.drv
building '/nix/store/hbsv13kn5imfri16f6g2l5c2jy6dfmxl-hello.drv'...
/nix/store/dsgf85gxzw167v320sy08as72c0hk8wd-hello

$ cat /nix/store/dsgf85gxzw167v320sy08as72c0hk8wd-hello
Hello World!
</code></pre>
<h2><a class="header" href="#explicit-dependencies" id="explicit-dependencies">Explicit Dependencies</a></h2>
<p>Inside <code>builtins.derivation</code>, almost all dependencies have to be provided
explicitly, even then bash shell that we are running on. Since we specify
<code>bash</code> as the builder program, it is also shown in the list of <code>inputDrvs</code>
of our derivation.</p>
<pre><code class="language-bash">$ nix show-derivation /nix/store/hbsv13kn5imfri16f6g2l5c2jy6dfmxl-hello.drv
{
  &quot;/nix/store/hbsv13kn5imfri16f6g2l5c2jy6dfmxl-hello.drv&quot;: {
    &quot;outputs&quot;: {
      &quot;out&quot;: {
        &quot;path&quot;: &quot;/nix/store/dsgf85gxzw167v320sy08as72c0hk8wd-hello&quot;
      }
    },
    &quot;inputSrcs&quot;: [],
    &quot;inputDrvs&quot;: {
      &quot;/nix/store/l54djrh1n7d8zdfn26w7v6zjh5wp7faa-bash-4.4-p23.drv&quot;: [
        &quot;out&quot;
      ]
    },
    &quot;platform&quot;: &quot;x86_64-linux&quot;,
    &quot;builder&quot;: &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;,
    &quot;args&quot;: [
      &quot;-c&quot;,
      &quot;echo \&quot;Hello World!\&quot; &gt; $out\n&quot;
    ],
    &quot;env&quot;: {
      &quot;builder&quot;: &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;,
      &quot;name&quot;: &quot;hello&quot;,
      &quot;out&quot;: &quot;/nix/store/dsgf85gxzw167v320sy08as72c0hk8wd-hello&quot;,
      &quot;system&quot;: &quot;x86_64-linux&quot;
    }
  }
}

</code></pre>
<h2><a class="header" href="#inspecting-the-build-environment" id="inspecting-the-build-environment">Inspecting the Build Environment</a></h2>
<p>We can use the <code>env</code> command to inspect the environment variables inside our build script.
Let's try and build a derivation that prints the environment to the terminal.</p>
<pre><code class="language-nix">nix-repl&gt; builtins.derivation {
            name = &quot;env&quot;;
            system = builtins.currentSystem;
            builder = &quot;${nixpkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot;
              ''
                set -x
                ls -la .
                ls -la /
                env
                touch $out
              ''
            ];
          }
«derivation /nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv
+ nix-build /nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv
these derivations will be built:
  /nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv
building '/nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv'...
+ ls -la .
bash: line 1: ls: command not found
+ ls -la /
bash: line 2: ls: command not found
+ env
bash: line 3: env: command not found
+ touch /nix/store/blcl4m2vgga6i86kh13nqlvx1l2ha7v5-env
bash: line 4: touch: command not found
builder for '/nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv' failed with exit code 127
error: build of '/nix/store/4nq2kgcmryhwjh5sg05jgwsd4ixh81ia-env.drv' failed
</code></pre>
<p>Not good, with <code>builtins.derivation</code>, not even basic commands like <code>ls</code>, <code>env</code>, and <code>touch</code>
are provided. (As seen previously, <code>echo</code> is provided though)</p>
<p>Instead, we also have to specify our build dependencies explicitly with <code>nixpkgs.coreutils</code>
providing the basic shell commands:</p>
<pre><code class="language-nix">nix-repl&gt; builtins.derivation {
            name = &quot;env&quot;;
            system = builtins.currentSystem;
            builder = &quot;${nixpkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot;
              ''
                set -x
                ${nixpkgs.coreutils}/bin/ls -la .
                ${nixpkgs.coreutils}/bin/ls -la /
                ${nixpkgs.coreutils}/bin/env
                ${nixpkgs.coreutils}/bin/touch $out
              ''
            ];
          }
«derivation /nix/store/c4bp5bvx73fz9jf1si64i00as30k9fga-env.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/c4bp5bvx73fz9jf1si64i00as30k9fga-env.drv
these derivations will be built:
  /nix/store/c4bp5bvx73fz9jf1si64i00as30k9fga-env.drv
building '/nix/store/c4bp5bvx73fz9jf1si64i00as30k9fga-env.drv'...
+ /nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/ls -la .
total 8
drwx------ 2 nixbld nixbld 4096 Nov 30 19:09 .
drwxr-x--- 9 nixbld nixbld 4096 Nov 30 19:09 ..
+ /nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/ls -la /
total 32
drwxr-x---   9 nixbld nixbld  4096 Nov 30 19:09 .
drwxr-x---   9 nixbld nixbld  4096 Nov 30 19:09 ..
drwxr-xr-x   2 nixbld nixbld  4096 Nov 30 19:09 bin
drwx------   2 nixbld nixbld  4096 Nov 30 19:09 build
drwxr-xr-x   4 nixbld nixbld  4096 Nov 30 19:09 dev
drwxr-xr-x   2 nixbld nixbld  4096 Nov 30 19:09 etc
drwxr-xr-x   3 nixbld nixbld  4096 Nov 30 19:09 nix
dr-xr-xr-x 410 nobody nogroup    0 Nov 30 19:09 proc
drwxrwxrwt   2 nixbld nixbld  4096 Nov 30 19:09 tmp
+ /nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/env
out=/nix/store/3rv14i75j4wyp6n9fila5rll4f99yksi-env
builder=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
NIX_LOG_FD=2
system=x86_64-linux
PWD=/build
HOME=/homeless-shelter
TMP=/build
NIX_STORE=/nix/store
TMPDIR=/build
name=env
TERM=xterm-256color
TEMPDIR=/build
SHLVL=1
NIX_BUILD_CORES=8
TEMP=/build
PATH=/path-not-set
NIX_BUILD_TOP=/build
_=/nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/env
+ /nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/touch /nix/store/3rv14i75j4wyp6n9fila5rll4f99yksi-env
/nix/store/3rv14i75j4wyp6n9fila5rll4f99yksi-env
</code></pre>
<h3><a class="header" href="#nix-sandbox" id="nix-sandbox">Nix Sandbox</a></h3>
<p>From above we can see that the build environment inside a Nix build script
is <em>sandboxed</em>.</p>
<p>According to
<a href="https://nixos.org/manual/nix/unstable/command-ref/conf-file.html">Nix manual</a>:</p>
<blockquote>
<p>If set to true, builds will be performed in a sandboxed environment, i.e., they’re isolated from the normal file system hierarchy and will only see their dependencies in the Nix store, the temporary build directory, private versions of /proc, /dev, /dev/shm and /dev/pts (on Linux), and the paths configured with the sandbox-paths option. This is useful to prevent undeclared dependencies on files in directories such as /usr/bin. In addition, on Linux, builds run in private PID, mount, network, IPC and UTS namespaces to isolate them from other processes in the system (except that fixed-output derivations do not run in private network namespace to ensure they can access the network).</p>
</blockquote>
<p>Nix sandbox should be enabled by default. You can check your sandbox configuration with:</p>
<pre><code class="language-bash">$ nix show-config | grep sandbox
extra-sandbox-paths =
sandbox = true
sandbox-build-dir = /build
sandbox-dev-shm-size = 50%
sandbox-fallback = true
sandbox-paths = /bin/sh=/nix/store/w0xp1k96c1dvmx6m4wl1569cdzy47w5r-busybox-1.31.1-x86_64-unknown-linux-musl/bin/busybox
</code></pre>
<h2><a class="header" href="#capturing-build-environment" id="capturing-build-environment">Capturing Build Environment</a></h2>
<p>We can capture the build environment as a file by saving the output of <code>env</code> to <code>$out</code>.</p>
<pre><code class="language-nix">nix-repl&gt; builtins.derivation {
            name = &quot;env&quot;;
            system = builtins.currentSystem;
            builder = &quot;${nixpkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot;
              &quot;${nixpkgs.coreutils}/bin/env &gt; $out&quot;
            ];
          }
«derivation /nix/store/39ah25v6iwlka3jl2angxrlx00mk2ijd-env.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/39ah25v6iwlka3jl2angxrlx00mk2ijd-env.drv
these derivations will be built:
  /nix/store/39ah25v6iwlka3jl2angxrlx00mk2ijd-env.drv
building '/nix/store/39ah25v6iwlka3jl2angxrlx00mk2ijd-env.drv'...
/nix/store/6kjgg8j3y44g1ja95swqdd1v8xp6mwi1-env

$ cat /nix/store/6kjgg8j3y44g1ja95swqdd1v8xp6mwi1-env
out=/nix/store/6kjgg8j3y44g1ja95swqdd1v8xp6mwi1-env
builder=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
NIX_LOG_FD=2
system=x86_64-linux
PWD=/build
HOME=/homeless-shelter
TMP=/build
NIX_STORE=/nix/store
TMPDIR=/build
name=env
TERM=xterm-256color
TEMPDIR=/build
SHLVL=1
NIX_BUILD_CORES=8
TEMP=/build
PATH=/path-not-set
NIX_BUILD_TOP=/build
_=/nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/env
</code></pre>
<h2><a class="header" href="#nix-shell-1" id="nix-shell-1">Nix Shell</a></h2>
<p>Nix achieves reproducible build by carefully setting/unsetting the appropriate
environment variables, so that our derivations are always built with the same
environment regardless of where it is being built.</p>
<p>However since the derivation is built in a sandboxed environment, it may be difficult
to debug when there are build errors, or rapid prototyping with the source code
changed frequently.</p>
<p>We can get almost the same environment as inside nix build by entering a <em>Nix shell</em>.</p>
<pre><code>$ nix-shell --pure --run env /nix/store/39ah25v6iwlka3jl2angxrlx00mk2ijd-env.drv
__ETC_PROFILE_SOURCED=1
DISPLAY=:1
out=/nix/store/6kjgg8j3y44g1ja95swqdd1v8xp6mwi1-env
builder=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
USER=user
system=x86_64-linux
PWD=/path/to/nix-workshop
HOME=/home/user
TMP=/run/user/1000
NIX_STORE=/nix/store
TMPDIR=/run/user/1000
name=env
IN_NIX_SHELL=pure
TERM=xterm-256color
TEMPDIR=/run/user/1000
SHLVL=3
NIX_BUILD_CORES=8
TEMP=/run/user/1000
LOGNAME=user
PATH=/nix/store/lf467z8nr5y50q1vqnlbhpv2jachx3cs-bash-interactive-4.4-p23/bin:/home/user/.nix-profile/bin:...
NIX_BUILD_TOP=/run/user/1000
_=/usr/bin/env
</code></pre>
<p>Our pure Nix environment look pretty similar to the environment we captured in <code>nix-build</code>.
There are however a few differences, in particular with <code>$PATH</code>.</p>
<p><a href="https://nixos.org/manual/nix/unstable/command-ref/nix-shell.html">According the manual</a>
for the <code>--pure</code> option in <code>nix-shell</code>:</p>
<blockquote>
<p>If this flag is specified, the environment is almost entirely cleared before the interactive shell is started, so you get an environment that more closely corresponds to the “real” Nix build. A few variables, in particular <code>HOME</code>, <code>USER</code> and <code>DISPLAY</code>, are retained. Note that (depending on your Bash installation) <code>/etc/bashrc</code> is still sourced, so any variables set there will affect the interactive shell.</p>
</blockquote>
<p>We can compare the differences by diffing the output of both environments:</p>
<pre><code class="language-bash">$ drv=/nix/store/39ah25v6iwlka3jl2angxrlx00mk2ijd-env.drv
$ diff --color &lt;(cat $(nix-build $drv)) &lt;(nix-shell $drv --pure --run env)
</code></pre>
<p>In contrast, the default impure Nix shell keeps all existing environment variables, and only
add or override variables that are introduced by the derivation.</p>
<pre><code class="language-bash">$ nix-shell $drv --run env
</code></pre>
<h2><a class="header" href="#environment-variables" id="environment-variables">Environment Variables</a></h2>
<p>If we observe the captured build environment, almost all attributes we passed to
<code>builtins.derivation</code> are converted into environment variables.</p>
<p>In fact, we can define any number of attributes to be used as environment variables
inside our build script.</p>
<pre><code class="language-nix">nix-repl&gt; builtins.derivation {
            name = &quot;foo&quot;;
            foo = &quot;foo val&quot;;
            system = builtins.currentSystem;
            builder = &quot;${nixpkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot;
              &quot;echo $foo &gt; $out&quot;
            ];
          }
«derivation /nix/store/v1i0khcvxy5bkyv2iq0kqzhcbfcfml8m-foo.drv»
</code></pre>
<p>We can see from the build output that the value of <code>$foo</code> is in fact
captured.</p>
<pre><code class="language-bash">$ nix-build /nix/store/v1i0khcvxy5bkyv2iq0kqzhcbfcfml8m-foo.drv
these derivations will be built:
  /nix/store/v1i0khcvxy5bkyv2iq0kqzhcbfcfml8m-foo.drv
building '/nix/store/v1i0khcvxy5bkyv2iq0kqzhcbfcfml8m-foo.drv'...
/nix/store/zmgp33rl2sh3l32syhq4h8gph3f4s1k9-foo

$ cat /nix/store/zmgp33rl2sh3l32syhq4h8gph3f4s1k9-foo
foo val
</code></pre>
<p>We can also get the same <code>$foo</code> variable set when entering Nix shell:</p>
<pre><code class="language-bash">$ nix-shell --pure --run 'echo $foo' /nix/store/v1i0khcvxy5bkyv2iq0kqzhcbfcfml8m-foo.drv
foo val
</code></pre>
<h2><a class="header" href="#setting-dependencies-as-variables" id="setting-dependencies-as-variables">Setting Dependencies as Variables</a></h2>
<p>We can set out dependencies as custom attributes in a derivation
and then refer to them as environment variables during the build.</p>
<p>For example, we can add the <code>greet</code> package we defined earlier
and set it as <code>$greet</code> in the shell.</p>
<pre><code class="language-nix">nix-repl&gt; greet = import ./04-derivations/02-dependencies/greet.nix

nix-repl&gt; builtins.derivation {
            inherit greet;
            name = &quot;greet-alice&quot;;
            system = builtins.currentSystem;
            builder = &quot;${nixpkgs.bash}/bin/bash&quot;;
            args = [
              &quot;-c&quot;
              &quot;$greet/bin/greet Alice &gt; $out&quot;
            ];
          }
«derivation /nix/store/68gdf6z0rjcyl8xcwix3gfafndsa50jj-greet-alice.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/68gdf6z0rjcyl8xcwix3gfafndsa50jj-greet-alice.drv
these derivations will be built:
  /nix/store/68gdf6z0rjcyl8xcwix3gfafndsa50jj-greet-alice.drv
building '/nix/store/68gdf6z0rjcyl8xcwix3gfafndsa50jj-greet-alice.drv'...
/nix/store/dd290zmn983fs1w33nnq9gyh3cnj2jif-greet-alice

$ cat /nix/store/dd290zmn983fs1w33nnq9gyh3cnj2jif-greet-alice
Hello, Alice!
</code></pre>
<h1><a class="header" href="#standard-derivation-1" id="standard-derivation-1">Standard Derivation</a></h1>
<p><code>builtins.derivation</code> provides the minimal functionality to define a Nix
derivation. However all dependencies have to be manually managed, which
can be pretty cumbersome. In practice, most Nix derivations are built
on top of <code>stdenv.mkDerivation</code>, which provide many battery-included
functionalities that helps make defining derivations easy.</p>
<p>The tradeoff is that <code>stdenv.mkDerivation</code> is much more complex than
<code>builtins.derivation</code>. With the detour to understand
<code>builtins.derivation</code> first, we can hopefully have an easier time
understanding <code>stdenv.mkDerivation</code></p>
<h2><a class="header" href="#inspecting-build-environment" id="inspecting-build-environment">Inspecting Build Environment</a></h2>
<p>We can inspect the standard environment in similar way.</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs.stdenv.mkDerivation {
            name = &quot;inspect&quot;;
            unpackPhase = &quot;true&quot;;

            buildPhase = ''
              set -x
              ls -la .
              ls -la /
              env
              set +x
            '';

            installPhase = &quot;touch $out&quot;;
          }
«derivation /nix/store/vdyp9cxs0li87app03vm8zbxmq0lhw5l-inspect.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/vdyp9cxs0li87app03vm8zbxmq0lhw5l-inspect.drv
these derivations will be built:
  /nix/store/vdyp9cxs0li87app03vm8zbxmq0lhw5l-inspect.drv
building '/nix/store/vdyp9cxs0li87app03vm8zbxmq0lhw5l-inspect.drv'...
unpacking sources
patching sources
configuring
no configure script, doing nothing
building
++ ls -la .
total 16
drwx------ 2 nixbld nixbld 4096 Nov 30 19:42 .
drwxr-x--- 9 nixbld nixbld 4096 Nov 30 19:42 ..
-rw-r--r-- 1 nixbld nixbld 5013 Nov 30 19:42 env-vars
++ ls -la /
total 32
drwxr-x---   9 nixbld nixbld  4096 Nov 30 19:42 .
drwxr-x---   9 nixbld nixbld  4096 Nov 30 19:42 ..
drwxr-xr-x   2 nixbld nixbld  4096 Nov 30 19:42 bin
drwx------   2 nixbld nixbld  4096 Nov 30 19:42 build
drwxr-xr-x   4 nixbld nixbld  4096 Nov 30 19:42 dev
drwxr-xr-x   2 nixbld nixbld  4096 Nov 30 19:42 etc
drwxr-xr-x   3 nixbld nixbld  4096 Nov 30 19:42 nix
dr-xr-xr-x 405 nobody nogroup    0 Nov 30 19:42 proc
drwxrwxrwt   2 nixbld nixbld  4096 Nov 30 19:42 tmp
++ env
...
unpackPhase=true
propagatedBuildInputs=
stdenv=/nix/store/ajq5dfwn4hzlx1qf2xxwb6rj8a7s65nm-stdenv-linux
TZ=UTC
OLDPWD=/build
out=/nix/store/a226brzfy71vr6vkfy4m188qs9f7k7g7-inspect
CONFIG_SHELL=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
buildInputs=
builder=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
...
buildPhase=set -x
ls -la .
ls -la /
env
set +x

PATH=/nix/store/cr86kfhzfwa558mzav4rnfkbz00hw27w-patchelf-0.12/bin:/nix/store/ppfvi0cfcpdr83klw5kx6si2l260n1gh-gcc-wrapper-9.3.0/bin:...
NIX_BUILD_TOP=/build
depsBuildTargetPropagated=
NIX_ENFORCE_PURITY=1
SIZE=size
nativeBuildInputs=
LD=ld
patches=
depsTargetTargetPropagated=
_=/nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin/env
++ set +x
installing
post-installation fixup
shrinking RPATHs of ELF executables and libraries in /nix/store/a226brzfy71vr6vkfy4m188qs9f7k7g7-inspect
strip is /nix/store/bnjps68g8ax6abzvys2xpx12imrx8949-binutils-2.31.1/bin/strip
patching script interpreter paths in /nix/store/a226brzfy71vr6vkfy4m188qs9f7k7g7-inspect
checking for references to /build/ in /nix/store/a226brzfy71vr6vkfy4m188qs9f7k7g7-inspect...
/nix/store/a226brzfy71vr6vkfy4m188qs9f7k7g7-inspect
</code></pre>
<p>As we can see, our standard environment is quite more complicated than the minimal environment
provided by <code>builtins.derivation</code>. We also have a number of executables added to <code>$PATH</code>,
which we can use without specifying them as dependencies.</p>
<h2><a class="header" href="#capturing-the-build-environment" id="capturing-the-build-environment">Capturing the Build Environment</a></h2>
<pre><code class="language-nix">nix-repl&gt; nixpkgs.stdenv.mkDerivation {
            name = &quot;env&quot;;
            unpackPhase = &quot;true&quot;;
            installPhase = &quot;env &gt; $out&quot;;
          }
«derivation /nix/store/5rgcvwndbc4525ypbb0r1vgqpbxgcy2g-env.drv»
</code></pre>
<pre><code class="language-bash">$ cat $(nix-build /nix/store/5rgcvwndbc4525ypbb0r1vgqpbxgcy2g-env.drv)
...
unpackPhase=true
propagatedBuildInputs=
stdenv=/nix/store/ajq5dfwn4hzlx1qf2xxwb6rj8a7s65nm-stdenv-linux
TZ=UTC
OLDPWD=/build
out=/nix/store/rkjhcjhdj6ba7r7n7fasq8gmzxi5hk72-env
CONFIG_SHELL=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
buildInputs=
builder=/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash
...
</code></pre>
<h2><a class="header" href="#build-inputs" id="build-inputs">Build Inputs</a></h2>
<p><code>stdenv.mkDerivation</code> also provides a convenient way of adding dependencies
to appropriate environment variables with the <code>buildInputs</code> attribute.</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs.stdenv.mkDerivation {
            name = &quot;greet-alice&quot;;
            buildInputs = [ greet ];

            unpackPhase = &quot;true&quot;;
            installPhase = &quot;greet Alice &gt; $out&quot;;
          }
«derivation /nix/store/in40c5fl13ziqzds3wfg2ag7ax2xmq5l-greet-alice.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/in40c5fl13ziqzds3wfg2ag7ax2xmq5l-greet-alice.drv
these derivations will be built:
  /nix/store/in40c5fl13ziqzds3wfg2ag7ax2xmq5l-greet-alice.drv
building '/nix/store/in40c5fl13ziqzds3wfg2ag7ax2xmq5l-greet-alice.drv'...
...
/nix/store/kp32rzq63barqa55q3mf761gsggi2bq6-greet-alice

$ cat /nix/store/kp32rzq63barqa55q3mf761gsggi2bq6-greet-alice
Hello, Alice!
</code></pre>
<p>We can check that <code>greet</code> is added to <code>$PATH</code> using Nix shell:</p>
<pre><code class="language-bash">$ drv=/nix/store/in40c5fl13ziqzds3wfg2ag7ax2xmq5l-greet-alice.drv

$ nix-shell $drv --pure --run &quot;command -v greet&quot;
/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin/greet

$ nix-shell $drv --pure --run 'echo $PATH' | tr ':' '\n'
...
/nix/store/2shqhfsyzz4rnfyysbzgyp5kbfk29750-coreutils-8.32/bin
/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet/bin
...
</code></pre>
<p><code>stdenv</code> also adds the build inputs to other variables.</p>
<pre><code>$ nix-shell $drv --pure --run 'echo $NIX_LDFLAGS'
-rpath /nix/store/kp32rzq63barqa55q3mf761gsggi2bq6-greet-alice/lib64 -rpath /nix/store/kp32rzq63barqa55q3mf761gsggi2bq6-greet-alice/lib
</code></pre>
<p>Note that the paths /nix/store/kp32rzq63barqa55q3mf761gsggi2bq6-greet-alice/lib
does not exist, but <code>stdenv</code> still sets the variables anyway.</p>
<h2><a class="header" href="#stdenv-script" id="stdenv-script">Stdenv Script</a></h2>
<p>How do <code>stdenv.mkDerivation</code> do the magic compared to <code>builtins.derivation</code>?
We can find out by first inspecting the derivation:</p>
<pre><code class="language-bash">$ nix show-derivation $drv
{
  &quot;/nix/store/in40c5fl13ziqzds3wfg2ag7ax2xmq5l-greet-alice.drv&quot;: {
    ...
    &quot;builder&quot;: &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;,
    &quot;args&quot;: [
      &quot;-e&quot;,
      &quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;
    ],
    &quot;env&quot;: {
      &quot;buildInputs&quot;: &quot;/nix/store/l6xy4qjr8x3ni16skfilw0fvnda13szq-greet&quot;,
      &quot;builder&quot;: &quot;/nix/store/qdp56fi357fgxxnkjrwx1g67hrk775im-bash-4.4-p23/bin/bash&quot;,
      ...
      &quot;installPhase&quot;: &quot;greet Alice &gt; $out&quot;,
      &quot;name&quot;: &quot;greet-alice&quot;,
      ...
      &quot;stdenv&quot;: &quot;/nix/store/ajq5dfwn4hzlx1qf2xxwb6rj8a7s65nm-stdenv-linux&quot;,
      ...
    }

  }
}
</code></pre>
<p><code>stdenv</code> is also using <code>bash</code> as the builder, and have it evaluate the
script at <code>/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh</code>.
Let's see what's inside there:</p>
<pre><code>$ cat /nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh
source $stdenv/setup
genericBuild
</code></pre>
<p>So the magic is hidden inside <code>$stdenv/setup</code>, with the <code>$stdenv</code>
variable set to <code>/nix/store/ajq5dfwn4hzlx1qf2xxwb6rj8a7s65nm-stdenv-linux</code>.</p>
<p>We can open it and see what's inside.</p>
<pre><code class="language-bash">nix-shell $drv --run 'cat $stdenv/setup'
</code></pre>
<p>There are quite a lot of shell scripts happening. If we search through the script,
we can see that environment variables such as <code>buildInputs</code>, <code>buildPhase</code>, and
<code>installPhase</code> are being referred inside <code>$stdenv/setup</code>.</p>
<p>In other words, instead of having to figure how to setup various environment
variables to work with various dependencies, <code>$stdenv/setup</code> provides a higher
level abstraction of doing the setup for us. We just have to define
the build inputs and steps that we need, and <code>$stdenv/setup</code> will fill
in the missing pieces from us.</p>
<p>In fact, <code>$stdenv/setup</code> is also being sourced when we enter a Nix shell of a
<code>stdenv</code> derivation.
From the <a href="https://nixos.org/manual/nix/unstable/command-ref/nix-shell.html">nix-shell manual</a>:</p>
<blockquote>
<p>The command nix-shell will build the dependencies of the specified derivation, but not the derivation itself. It will then start an interactive shell in which all environment variables defined by the derivation path have been set to their corresponding values, and the script $stdenv/setup has been sourced. This is useful for reproducing the environment of a derivation for development.</p>
</blockquote>
<h2><a class="header" href="#deriving-environment-at-build-time" id="deriving-environment-at-build-time">Deriving Environment at Build Time</a></h2>
<p>One question we might ask is, why is <code>stdenv</code> doing the heavyweight steps only
at build time inside a shell script. We could as well parse the dependencies
inside Nix at evaluation time, and produce a derivation with everything
setup already.</p>
<p>However recall from the <a href="04-derivations/./03-fibonacci.html">previous example</a> of
<code>fib-serialized.nix</code>. If we try to peek into the content of a dependency derivation,
that would instead become an evaluation time dependency. If <code>stdenv</code> is
looking into the content of all dependencies inside Nix, then we can
only know how to build the derivation after all dependencies have been built.</p>
<p>Instead, <code>stdenv</code> avoids this to allow the derivation dependencies to
be built in parallel by Nix. With that, we can only read the content
of our dependencies at build time, which happens inside the build script.</p>
<h1><a class="header" href="#build-phases" id="build-phases">Build Phases</a></h1>
<p><code>stdenv</code> provides many different phases, with default behavior of
what to run if no script for that phase is provided.</p>
<p>Many of the phases follow the build steps introduced by
<a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html">Autotools</a>.
When we are building non-C/C++ projects, only a few phases are essential.
Still, it is useful to take a quick look at what phases are there,
and what they offers.</p>
<p>The <a href="https://nixos.org/manual/nixpkgs/unstable/#sec-stdenv-phases">nixpkgs manual</a>
has the full list of phases.</p>
<h2><a class="header" href="#the-phases-attribute" id="the-phases-attribute">The <code>phases</code> Attribute</a></h2>
<p>We can force <code>stdenv</code> to run only specific phases by specifying them
in the <code>phases</code> attribute.</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs.stdenv.mkDerivation {
            name = &quot;hello&quot;;
            phases = [ &quot;installPhase&quot; ];
            installPhase = &quot;echo 'Hello World!' &gt; $out&quot;;
          }
«derivation /nix/store/m09hj2xs3yc45y3d4rdm8wks7cay00ak-hello.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/m09hj2xs3yc45y3d4rdm8wks7cay00ak-hello.drv
these derivations will be built:
  /nix/store/m09hj2xs3yc45y3d4rdm8wks7cay00ak-hello.drv
building '/nix/store/m09hj2xs3yc45y3d4rdm8wks7cay00ak-hello.drv'...
installing
/nix/store/hpj3y6as9s07444qi6nap0f5dp5k84b6-hello

$ cat /nix/store/hpj3y6as9s07444qi6nap0f5dp5k84b6-hello
Hello World!
</code></pre>
<p>You may notice that the build log for this version of <code>hello</code> is much shorter
than the usual output of standard derivations. Messages such as
<code>post-installation fixup</code> are not shown here.</p>
<p>This is because those are implicit steps performed in phases such as <code>fixupPhase</code>.
We will go through later why those phases are there. But as you can see, these
phases can be disabled by explicitly specifying the <code>phases</code> to run.</p>
<p>There is also no need to explicitly skip required phases like <code>unpackPhase</code>,
which we previously set to <code>true</code>.</p>
<h2><a class="header" href="#unpack-phase" id="unpack-phase">Unpack Phase</a></h2>
<p>The unpack phase is used to unpack source code into temporary directories
to be used for compilation. By default, <code>unpackPhase</code> unpacks the source
code specified in <code>$src</code>, and if none is provided, it will abort with an error.</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs.stdenv.mkDerivation {
            name = &quot;hello&quot;;
            installPhase = &quot;echo 'Hello World!' &gt; $out&quot;;
          }
«derivation /nix/store/cx3p30jp0y0l8ixl426drsp81vcqagpr-hello.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/cx3p30jp0y0l8ixl426drsp81vcqagpr-hello.drv
these derivations will be built:
  /nix/store/cx3p30jp0y0l8ixl426drsp81vcqagpr-hello.drv
building '/nix/store/cx3p30jp0y0l8ixl426drsp81vcqagpr-hello.drv'...
unpacking sources
variable $src or $srcs should point to the source
builder for '/nix/store/cx3p30jp0y0l8ixl426drsp81vcqagpr-hello.drv' failed with exit code 1
error: build of '/nix/store/cx3p30jp0y0l8ixl426drsp81vcqagpr-hello.drv' failed
</code></pre>
<p>This is why when we don't have any source code, we have to explicitly skip
the <code>unpackPhase</code> by telling it to run <code>true</code> instead.</p>
<p>Let's try to see what is done in <code>unpackPhase</code> when we give it some source directories.</p>
<pre><code class="language-nix">nix-repl&gt; nixpkgs.stdenv.mkDerivation {
            name = &quot;fibonacci-src&quot;;
            src = ./04-derivations/03-fibonacci;
            installPhase = ''
              set -x

              pwd
              ls -la .
              cp -r ./ $out/

              set +x
            '';
          }
«derivation /nix/store/8l0s01nk0fc1zicb9qkdmpwsw01qr5p8-fibonacci.drv»
</code></pre>
<pre><code class="language-bash">$ nix-build /nix/store/8l0s01nk0fc1zicb9qkdmpwsw01qr5p8-fibonacci.drv
these derivations will be built:
  /nix/store/8l0s01nk0fc1zicb9qkdmpwsw01qr5p8-fibonacci.drv
building '/nix/store/8l0s01nk0fc1zicb9qkdmpwsw01qr5p8-fibonacci.drv'...
unpacking sources
unpacking source archive /nix/store/a5f73yy0a8dn0p12pfriqbqyag0ksfkq-03-fibonacci
source root is 03-fibonacci
patching sources
configuring
no configure script, doing nothing
building
no Makefile, doing nothing
installing
++ pwd
/build/03-fibonacci
++ ls -la .
total 16
drwxr-xr-x 2 nixbld nixbld 4096 Jan  1  1970 .
drwx------ 3 nixbld nixbld 4096 Dec  1 09:19 ..
-rw-r--r-- 1 nixbld nixbld 1772 Jan  1  1970 fib-serialized.nix
-rw-r--r-- 1 nixbld nixbld 1602 Jan  1  1970 fib.nix
++ cp -r ./ /nix/store/qqd4msyqya0xhqxcyra0lf7v09z2q522-fibonacci/
++ set +x
post-installation fixup
shrinking RPATHs of ELF executables and libraries in /nix/store/qqd4msyqya0xhqxcyra0lf7v09z2q522-fibonacci
strip is /nix/store/bnjps68g8ax6abzvys2xpx12imrx8949-binutils-2.31.1/bin/strip
patching script interpreter paths in /nix/store/qqd4msyqya0xhqxcyra0lf7v09z2q522-fibonacci
checking for references to /build/ in /nix/store/qqd4msyqya0xhqxcyra0lf7v09z2q522-fibonacci...
/nix/store/qqd4msyqya0xhqxcyra0lf7v09z2q522-fibonacci

$ ls -la /nix/store/qqd4msyqya0xhqxcyra0lf7v09z2q522-fibonacci
total 5728
dr-xr-xr-x    2 user user    4096 Jan  1  1970 .
drwxr-xr-x 5403 user user 5849088 Dez  1 10:19 ..
-r--r--r--    1 user user    1602 Jan  1  1970 fib.nix
-r--r--r--    1 user user    1772 Jan  1  1970 fib-serialized.nix
</code></pre>
<p>As we can see, <code>unpackPhase</code> copies the content of the source code specified in <code>$src</code>
into the temporary build directory. It also modifies the chmod permissions to
allow write permission to the files and directories.</p>
<h2><a class="header" href="#patch-phase" id="patch-phase">Patch Phase</a></h2>
<h2><a class="header" href="#configure-phase" id="configure-phase">Configure Phase</a></h2>
<h2><a class="header" href="#build-phase" id="build-phase">Build Phase</a></h2>
<h2><a class="header" href="#check-phase" id="check-phase">Check Phase</a></h2>
<h2><a class="header" href="#install-phase" id="install-phase">Install Phase</a></h2>
<h2><a class="header" href="#fixup-phase" id="fixup-phase">Fixup Phase</a></h2>
<h1><a class="header" href="#dependency-management" id="dependency-management">Dependency Management</a></h1>
<p>We have seen in previous chapters that Nix makes it easy to construct
complex build depedencies with several benefits:</p>
<ul>
<li>Non-related dependencies can be built in parallel.</li>
<li>Reproducible builds make it easy to cache and reuse dependencies.</li>
</ul>
<p>However Nix does not provide any mechanism for dependency <em>resolution</em>,
e.g. choose from multiple <em>versions</em> of dependencies and
determining the most suitable versions.</p>
<p>As an example, we will build hypothetical Nix packages resembling
<a href="https://minecraft.gamepedia.com/Crafting">Minecraft crafting recipes</a>
with versioning schemes following <a href="https://semver.org/">semver</a>.
Let's first try to build our first version of <code>pickaxe</code>, which is
made of wood:</p>
<pre><code>pickaxe
  - 1.0.0
    - stick ^1.0.1
    - planks ~2.1.0
stick
  - 1.0.3
  - 1.1.2
  - 2.0.0
planks
  - 2.1.0
  - 2.1.1
  - 2.2.1
</code></pre>
<p>The first step in deciding the appropriate versions to be used to build
<code>pickaxe-1.0.0</code> is to rule out invalid versions. With that, <code>stick-2.0.0</code>
is ruled out because it is outside of the <code>^1.0.1</code> range. Similarly
<code>planks-2.2.1</code> is outside the bound for <code>~2.1.0</code>.</p>
<p>After filtering out the invalid versions, there are still multiple versions
of <code>stick</code> and <code>planks</code> available. As a result there can be multiple
version candidates for building <code>pickaxe-1.0.0</code>. For example, we can use
<code>stick-1.0.3</code> and <code>planks-2.1.1</code>. But are those the best versions to be used?</p>
<p>Depending on the dependency resolution algorithm used, we may get different
answers. Though in general, we can usually expect the algorithm to choose
the latest versions that are compatible with the required range. So we should
expect to get <code>stick-1.1.2</code> and <code>planks-2.1.1</code> as the answers.</p>
<h2><a class="header" href="#nested-dependencies" id="nested-dependencies">Nested Dependencies</a></h2>
<p>In reality, dependency resolution can be more complicated because of
<em>nested</em> dependencies. Let's say both <code>stick</code> and <code>planks</code> both depend
on <code>wood</code>:</p>
<pre><code>stick
  - 1.0.3
    - wood ^1.5.0
  - 1.1.2
    - wood ~2.0.0

planks
  - 2.1.0
    - wood ^2.0.0
  - 2.1.1
    - wood ~2.3.0

wood
  - 1.5.0
  - 2.0.1
  - 2.3.2
</code></pre>
<p>In such case, the only solution is to use <code>stick-1.1.2</code> and <code>planks-2.1.0</code>,
because the other version combinations do not have a common <code>wood</code> version
usable by both <code>stick</code> and <code>planks</code>.</p>
<h2><a class="header" href="#package-managers" id="package-managers">Package Managers</a></h2>
<p>Dependency resolution is a complex topic on its own. Different languages
have their own package managers that deal with dependency resolution
differently. e.g. cabal-install, npm, mvn, etc. There are also OS-level
package managers that have to deal with dependencies resolution.
e.g. Debian, Ubuntu, Fedora, Arch, etc.</p>
<p>To support package management across multiple languages and multiple
platforms, Nix has its own unique challenge of managing dependencies.
At this point, Nix itself do not provide any mechanism for resolving
dependencies. Instead Nix users have to come out with their own
higher level design patterns to resolve dependencies, such as in
nixpkgs.</p>
<h2><a class="header" href="#package-registry" id="package-registry">Package Registry</a></h2>
<p>For a dependency resolution algorithm to determine what versions of
dependency to use, it must first refer to a <em>registry</em> that contains
all versions available to all packages. Each package manager have
their own registry, e.g. Hackage, npm registry, Debian registry, etc.</p>
<p>Package registries are usually mutable databases that are constantly
updated. This creates an issue with <em>reproducibility</em>: the result
given back from a dependency resolution algorithm depends on
the mutable state of the registry at the time the algorithm is
executed.</p>
<p>In other words, say if we try to resolve the dependencies of
<code>pickaxe-1.0.0</code> today, we may get <code>stick-1.1.2</code> and <code>planks-2.1.0</code>.
But if we resolve the same dependencies tomorrow, we might get
<code>stick-1.1.3</code> because new version of <code>stick</code> is published.
To make it worse, <code>stick-1.1.3</code> may contain unexpected changes
that causes <code>pickaxe-1.0.0</code> to break.</p>
<h2><a class="header" href="#version-pinning" id="version-pinning">Version Pinning</a></h2>
<p>Even without Nix, there is a strong use case to fix the pin versions
to a particular snapshot in time. This is to make sure no matter when
we try to resolve the dependencies in the future, we will always get
back the exact dependencies.</p>
<h3><a class="header" href="#package-lock" id="package-lock">Package Lock</a></h3>
<p>One common approach is to create a lock file containing the result of
running the dependency resolution algorithm, and check in the lock file
into the version control system. Examples are <code>package-lock.json</code> and
<code>cabal.project.freeze</code>. With the lock files available, we can even
skip dependency resolution in the future, and just use the result in the
lock file.</p>
<p>Although lock files help provide strong reproducibility to managing
dependencies, it has the downside of adding noise to version control.
When we generate a new lock file in the future to get new dependency
versions, the new lock file may contain a lot of changes, and this
may affect the diff output when inspect the commit history.</p>
<h3><a class="header" href="#registry-snapshot" id="registry-snapshot">Registry Snapshot</a></h3>
<p>An alternative approach would be to specify the snapshot of the
package registry itself. For example, cabal accepts an
<code>index-state</code> option for us to specify a timestamp of the
Hackage snapshot that it should resolve the dependencies from.
With that we can specify the timestamp of the time we first
build our dependencies, and not worry about new versions of
packages being added in the future.</p>
<p>Specifying the snapshot version of the registry also result in
cleaner commit logs. However there can still be other variables
that can affect the outcome. For example, the package manager
itself may update the dependency resolution algorithm, so we
may still get different results depending on the version of
package manager used.</p>
<h2><a class="header" href="#upgrading-dependencies" id="upgrading-dependencies">Upgrading Dependencies</a></h2>
<p>The strategies for pinning dependencies does not eliminate the
need to resolving the plans in the first place, or the need
to upgrade or install new depedencies.</p>
<p>In the ideal world, we would like to be able to just specify
the dependencies we need, and have the package manager give
us the best versions that just work. But reality is messy,
and dependencies can have breaking changes all the time.</p>
<h3><a class="header" href="#versioning-schemes" id="versioning-schemes">Versioning Schemes</a></h3>
<p>There are many attempts at coming up with versioning schemes
that carry breakage information with them, such as
<a href="https://semver.org/">semver</a> and
<a href="https://pvp.haskell.org/">PVP</a>.
However they require package authors to manually follow
the rules, and rules can be broken, intentionally or not.</p>
<h2><a class="header" href="#exponential-versions" id="exponential-versions">Exponential Versions</a></h2>
<p>In reality, each combination of dependency versions produce
a unique version of the full package that needs to be tested.
There is never just one version of <code>pickaxe-1.0.0</code>, but
exponential number of versions of <code>pickaxe-1.0.0</code> depending
on the versions of <code>stick</code>, <code>planks</code>, and their transitive
dependencies.</p>
<p>To make matters worse, real world software also tend to have
implicit dependencies on the runtime environment, such as
executables, shared libraries, and operating system APIs.</p>
<p>So for each of the versions of <code>pickaxe-1.0.0</code> with pinned
dependencies, we would also have multiple versions of that
software for different platforms, e.g. Linux, MacOS, Windows,
Android, iOS, etc. Even among these platforms, there are
also multiple releases of the platform, e.g. Debian 10,
Ubuntu 20.04, MacOS Big Sur, etc.</p>
<h2><a class="header" href="#mono-versioning" id="mono-versioning">Mono Versioning</a></h2>
<p>Despite all these complexities, we still like to pretend
that there is only one or few versions of <code>pickaxe-1.0.0</code>
ever existed. One way to tame down this complexity is
through <em>mono versioning</em>.</p>
<h3><a class="header" href="#monorepo" id="monorepo">Monorepo</a></h3>
<p>The simplest kind of mono versioning is by having a single repository
that contains all its components and dependencies. For each commit
in this repository, there is exactly one version each component
and dependecy. We simply ignore the possibility of other
valid combinations of component versions, and not support them.</p>
<h3><a class="header" href="#lockfiles-in-monorepo" id="lockfiles-in-monorepo">Lockfiles in Monorepo</a></h3>
<p>Package managers such as <code>godep</code> check in the source code of dependencies
into a monorepo. However that can greatly pollute the commit history.
As an alternative, we can check in just the lockfiles into the repostory,
and have the package managers fetch them separately.</p>
<p>Checking in the lock file is still effectively mono-versioning the
dependencies. For each commit in the repository, we support only the
exact dependencies specified in the lockfile of that commit. We simply
pretend that no other versions of the dependencies are available.</p>
<h3><a class="header" href="#mono-registry" id="mono-registry">Mono Registry</a></h3>
<p>Taking the idea to extreme, we can also freeze all dependencies in a package
registry and provide only one version of each dependency at any point in time.</p>
<p>This is the approach for registries such as Stackage, which guarantees that
all Haskell dependencies only have one version that always work.</p>
<p>Mono registry tend to work more cleanly together with monorepo. In a project,
we can specify just the snapshot version of the mono registry that we are
using, and there is no need for messy details such as generating the lockfiles
in the first place.</p>
<h3><a class="header" href="#mono-environment" id="mono-environment">Mono Environment</a></h3>
<p>Nixpkgs is also a mono registry for the standard packages in Nix. For each
version of nixpkgs, there is exactly one version of packages such as <code>bash</code>,
<code>gcc</code>, etc. But since these packages used to be provided by operating
systems, we can say that nixpkgs is also providing a <em>mono environment</em>
to our software.</p>
<p>When we create a monorepo with pinned nixpkgs, we are not only providing
exactly one version of each dependencies, but also exactly one version
of the environment to run on.</p>
<p>Mono environment restricts the specification of our software so that it
does not just run on platforms such as any version of Linux or any
version of Debian 10. We just pretend that there is exact one version
of OS as specified in nixpkgs.</p>
<h2><a class="header" href="#pros-and-cons-of-mono-versioning" id="pros-and-cons-of-mono-versioning">Pros and Cons of Mono Versioning</a></h2>
<p>There is a fundamental difference in philosophy between multi-versioning
and mono-versioning that makes it difficult for the two camps to reconcile.
At its core, there are a few factors involved.</p>
<h3><a class="header" href="#stability" id="stability">Stability</a></h3>
<p>Mono-versioning places much higher value in stability. People in this camp
want to make sure each version of the software always work. They achieve
that by significantly limit the number of versions of the software,
and throughoutly test the software before upgrading any version.</p>
<p>Mono-versioning tend to put emphasis in LTS (long term support) releases,
where its components are guaranteed to not have any breaking changes
and be given years of support.</p>
<h3><a class="header" href="#rapid-releases" id="rapid-releases">Rapid Releases</a></h3>
<p>Mono versioning tend to suffer in providing slower releases. When a
new version of component is available, it has to be tested to not
break any other component before the new version can be released.</p>
<p>In contrast, multi-versioning allows a new component to be released
immediately. This allows software to independently upgrade the
dependencies, at the risk of it may break on some of the software.</p>
<h2><a class="header" href="#blurring-the-line" id="blurring-the-line">Blurring the Line</a></h2>
<p>There is no clear cut of whether the mono-versioning or multi-versioning
approaches are better. In practice, we tend to take a hybrid approach
in large software projects.</p>
<p>For example, in a company each team may have different monorepos for their
projects to manage their own dependencies. The full release of the software
suite is then a multi-versioning combination of each team's projects,
which can break during development. Finally in production, the exact
versions of each subprojects are pinned to specific versions before
deployment.</p>
<p>Although Nix is more suitable for mono-versioning development, some of
its features also make it easier to manage multi-versioned projects,
by building a mono &quot;Nixified&quot; version of the projects.</p>
<h1><a class="header" href="#basic-haskell-project" id="basic-haskell-project">Basic Haskell Project</a></h1>
<p>We will take a quick look on the Nix structure for a trivial Haskell project,
in <a href="05-package-management/./haskell-project-v1">haskell-project-v1</a>.</p>
<p><code>Main.hs</code>:</p>
<pre><code class="language-haskell">module Main where

main :: IO ()
main = putStrLn &quot;Hello, Haskell!&quot;
</code></pre>
<p><code>haskell-project.cabal</code>:</p>
<pre><code>cabal-version:       2.4
name:                haskell-project
version:             0.1.0.0
license:             ISC
build-type:          Simple

executable hello
  main-is:             Main.hs
  build-depends:       base &gt;=4.13
  default-language:    Haskell2010
</code></pre>
<h2><a class="header" href="#nix-dependency-management-with-niv" id="nix-dependency-management-with-niv">Nix Dependency Management with Niv</a></h2>
<p>We will use multiple Nix sources including nixpkgs and Haskell.nix
in our Haskell projects. However specifying the Nix dependencies
explicitly like in <a href="05-package-management/../nixpkgs.nix"><code>nixpkgs.nix</code></a> can be a bit
cumbersome.</p>
<pre><code class="language-nix">let
  nixpkgs-src = builtins.fetchTarball {
    url = &quot;https://github.com/NixOS/nixpkgs/archive/fcc81bc974fabd86991b8962bd30a47eb43e7d34.tar.gz&quot;;
    sha256 = &quot;1ysjmn79pl7srlzgfr35nsxq43rm1va8dqp60h09nlmw2fsq9zrc&quot;;
  };

  nixpkgs = import nixpkgs-src {};
in
nixpkgs
</code></pre>
<p>Instead we can use <a href="https://github.com/nmattia/niv.git">niv</a> to
manage the dependencies for us. Niv allows us to easily add
any remote sources as a Nix dependency, and provide them
in a single <code>sources</code> object.</p>
<p>We can initialize niv in the project directory as follows:</p>
<pre><code class="language-bash">$ nix-shell -j4 -E \
  'let nixpkgs = import ./nixpkgs.nix;
    in nixpkgs.mkShell { buildInputs = [ nixpkgs.niv ]; }'

[nix-shell]$ 05-package-management/haskell-project-v1

[nix-shell]$ niv init
</code></pre>
<p>By default, niv will initialize with the latest nixpkgs version
available. We can explicitly override the commit version of
nixpkgs to the one in this tutorial.</p>
<pre><code class="language-bash">[nix-shell]$ niv update nixpkgs --branch nixpkgs-unstable \
              --rev c1e5f8723ceb684c8d501d4d4a
e738fef704747e
Update nixpkgs
Done: Update nixpkgs
</code></pre>
<p>We can also add new dependencies such as Haskell.nix using
<code>niv add</code>:</p>
<pre><code class="language-bash">[nix-shell]$ niv add input-output-hk/haskell.nix \
              --rev 180779b7f530dcd2a45c7d00541f0f3e3d8471b5
Adding package haskell.nix
  Writing new sources file
Done: Adding package haskell.nix
</code></pre>
<p>Two new files, <code>nix/sources.json</code> and <code>sources.nix</code> will be created
by niv. To load the source dependencies, we can simply do
<code>sources = import ./nix/sources.nix {}</code> to import the source object.
The source files are then available in the corresponding
attributes of the sources object, such as <code>sources.nixpkgs</code>.</p>
<h2><a class="header" href="#naive-attempt" id="naive-attempt">Naive Attempt</a></h2>
<p>Let's try to create a naive
<a href="05-package-management/./haskell-project-v1/nix/01-naive/default.nix">default.nix</a>
that tries to build with cabal directly:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsPkgs = nixpkgs.haskell.packages.ghc8102;

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };
in
nixpkgs.stdenv.mkDerivation {
  inherit src;

  name = &quot;haskell-project&quot;;

  buildInputs = [
    hsPkgs.ghc
    hsPkgs.cabal-install
  ];

  builPhase = ''
    cabal build all
  '';

  installPhase = ''
    cabal install --installdir=$out --install-method=copy
  '';
}
</code></pre>
<ul>
<li>
<p>We use <code>builtins.path</code> to include our Haskell source code, with
a filter function to filter out the local <code>dist-newstyle</code>
directory.</p>
</li>
<li>
<p>We use GHC 8.10.2 provided from <code>nixpkgs.haskell.packages.ghc8102</code>.</p>
</li>
<li>
<p>We add <code>ghc</code> and <code>cabal-install</code> into <code>buildInputs</code>.</p>
</li>
</ul>
<p>Try building it:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v1/nix/01-naive/
these derivations will be built:
  /nix/store/w1yscims73lrypddqcnri2vphqfnbim6-haskell-project.drv
building '/nix/store/w1yscims73lrypddqcnri2vphqfnbim6-haskell-project.drv'...
unpacking sources
unpacking source archive /nix/store/rc0pr7b71fm84az7d3gk4pdk62v8s0j0-haskell-project-src
source root is haskell-project-src
patching sources
configuring
no configure script, doing nothing
building
no Makefile, doing nothing
installing
Config file path source is default config file.
Config file /homeless-shelter/.cabal/config not found.
Writing default configuration to /homeless-shelter/.cabal/config
dieVerbatim: user error (cabal: Couldn't establish HTTP connection. Possible cause: HTTP proxy server
is down.
)
builder for '/nix/store/w1yscims73lrypddqcnri2vphqfnbim6-haskell-project.drv' failed with exit code 1
error: build of '/nix/store/w1yscims73lrypddqcnri2vphqfnbim6-haskell-project.drv' failed
</code></pre>
<p>Not good. Cabal tries to access the network to get the current Hackage
registry state and fails. There is good reason for this - there is no way
for Nix to know that cabal's access to network is reproducible.</p>
<p>We can still use it as a Nix shell to build our project manually, because
there is network access in Nix shell.</p>
<pre><code class="language-bash">$ nix-shell 05-package-management/haskell-project-v1/nix/01-naive/

[nix-shell]$ cd 05-package-management/haskell-project-v1/haskell

[nix-shell]$ cabal build all
Resolving dependencies...
Build profile: -w ghc-8.10.2 -O1
In order, the following will be built (use -v for more details):
 - haskell-project-0.1.0.0 (exe:hello) (first run)
Configuring executable 'hello' for haskell-project-0.1.0.0..
Preprocessing executable 'hello' for haskell-project-0.1.0.0..
Building executable 'hello' for haskell-project-0.1.0.0..
[1 of 1] Compiling Main             ( Main.hs, /mnt/gamma/scrive/nix-workshop/code/05-package-management/haskell-project-v1/haskell/dist-newstyle/build/x86_64-linux/ghc-8.10.2/haskell-project-0.1.0.0/x/hello/build/hello/hello-tmp/Main.o )
Linking /mnt/gamma/scrive/nix-workshop/code/05-package-management/haskell-project-v1/haskell/dist-newstyle/build/x86_64-linux/ghc-8.10.2/haskell-project-0.1.0.0/x/hello/build/hello/hello ...
</code></pre>
<h2><a class="header" href="#default-attempt" id="default-attempt">Default Attempt</a></h2>
<p>We can instead try the default way of building Haskell packages in Nix.
There is a full tutorial by
<a href="https://github.com/Gabriel439/haskell-nix">Gabriel</a>. Here we will
just take a quick tour.</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsPkgs = nixpkgs.haskell.packages.ghc8102;

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<ul>
<li>
<p>We use the <code>hsPkgs.callCabal2nix</code> function to create a nixpkgs-style package.</p>
</li>
<li>
<p>We then call <code>hsPkgs.callPackage</code> to &quot;instantiate&quot; our project with the
dependencies taken from <code>hsPkgs</code>.</p>
</li>
</ul>
<p>Now try to build it:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v1/nix/02-nixpkgs/
building '/nix/store/8rgnd9620lf287i0nw4j3z4wb01pd36a-cabal2nix-haskell-project.drv'...
installing
these derivations will be built:
  /nix/store/as92yri0vvfi5yck5gajckfx064fy0qy-haskell-project-0.1.0.0.drv
building '/nix/store/as92yri0vvfi5yck5gajckfx064fy0qy-haskell-project-0.1.0.0.drv'...
...
Preprocessing executable 'hello' for haskell-project-0.1.0.0..
Building executable 'hello' for haskell-project-0.1.0.0..
[1 of 1] Compiling Main             ( Main.hs, dist/build/hello/hello-tmp/Main.o )
Linking dist/build/hello/hello ...
...
/nix/store/3aq34n1ba3pvl6cs6f63xd737fz6604r-haskell-project-0.1.0.0

$ /nix/store/3aq34n1ba3pvl6cs6f63xd737fz6604r-haskell-project-0.1.0.0/bin/hello
Hello, Haskell!
</code></pre>
<p>That works. We can also create a separate <code>shell.nix</code> to derive a Nix shell
environment based on our Haskell environment.</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsPkgs = nixpkgs.haskell.packages.ghc8102;

  project = import ./default.nix;
in
nixpkgs.mkShell {
  name = &quot;cabal-shell&quot;;
  inputsFrom = [ project.env ];
  buildInputs = [
    hsPkgs.cabal-install
  ];
}
</code></pre>
<p>We use <code>nixpkgs.mkShell</code> to create a Nix derivation that is explicitly used
for Nix shell. <code>inputsFrom</code> propagates all build inputs of a derivation to
the new derivation. We use <code>project.env</code> which is a sub-derivation given
by <code>callCabal2nix</code> which contains the GHC shell environment for building
our project.</p>
<p>Notice that we have to explicitly provide <code>cabal-install</code> as <code>buildInput</code>
to our shell derivation. This shows that internally, the Haskell packages
in nixpkgs are built by directly calling GHC, skipping <code>cabal</code> entirely.</p>
<h2><a class="header" href="#how-haskell-in-nixpkgs-work" id="how-haskell-in-nixpkgs-work">How Haskell in Nixpkgs Work</a></h2>
<p>The Haskell packages in nixpkgs are <em>mono-versioned</em>. This means for each
Haskell package such as <code>base</code>, <code>aeson</code>, etc, there is exactly one version
provided by a Haskell packages set. There are however multiple versions
of Haskell packages in nixpkgs, determined by the GHC versions.</p>
<p>For instance, <code>nixpkgs.haskell.packages.ghc8102</code> contains mono-versioned
Haskell packages that works in GHC 8.10.2, while
<code>nixpkgs.haskell.packages.ghc884</code> contains mono-versioned Haskell packages
that works in GHC 8.8.4.</p>
<pre><code class="language-bash">$ nix-shell 05-package-management/haskell-project-v1/nix/02-nixpkgs/shell.nix

[nix-shell]$ cd 05-package-management/haskell-project-v1/haskell/

[nix-shell]$ cabal build all
Resolving dependencies...
Build profile: -w ghc-8.10.2 -O1
In order, the following will be built (use -v for more details):
 - haskell-project-0.1.0.0 (exe:hello) (first run)
Configuring executable 'hello' for haskell-project-0.1.0.0..
Preprocessing executable 'hello' for haskell-project-0.1.0.0..
Building executable 'hello' for haskell-project-0.1.0.0..
[1 of 1] Compiling Main             ( Main.hs, /mnt/gamma/scrive/nix-workshop/code/05-package-management/haskell-project-v1/haskell/dist-newstyle/build/x86_64-linux/ghc-8.10.2/haskell-project-0.1.0.0/x/hello/build/hello/hello-tmp/Main.o )
Linking /mnt/gamma/scrive/nix-workshop/code/05-package-management/haskell-project-v1/haskell/dist-newstyle/build/x86_64-linux/ghc-8.10.2/haskell-project-0.1.0.0/x/hello/build/hello/hello ...
</code></pre>
<h3><a class="header" href="#stackage-upstream" id="stackage-upstream">Stackage Upstream</a></h3>
<p>The mono versions of Haskell packages used to follow Stackage LTS,
which is also mono-versioned. However recently the team have
<a href="https://discourse.nixos.org/t/new-ghc-default-version-8-10-2-package-versions-now-from-stackage-nightly/10117">switched to Stackage nightly</a>
to reduce the maintenance burden.</p>
<h3><a class="header" href="#callpackage-pattern" id="callpackage-pattern">Callpackage Pattern</a></h3>
<p>As we discussed in previous chapter, Nix itself do not provide any
mechanism for dependency resolution. So nixpkgs come out with the
<a href="https://nixos.org/guides/nix-pills/callpackage-design-pattern.html">Callpackge design pattern</a>
to manage dependencies in nixpkgs.</p>
<p>In short, we define new packages in function form which accept
dependencies as function inputs. Let's call these functions
<em>partial packages</em>, since they are packages with dependencies
yet to be supplied.</p>
<p>For example, the <code>pickaxe</code> package we defined previously would
have a partial package definition that looks something like:</p>
<pre><code class="language-nix">let pickaxe = { stick, planks }: ...
</code></pre>
<p>The partial package is then instantiated into a Nix derivation
by calling <code>nixpkgs.callPackage</code> with the package set containing
all its dependencies as partial packages.</p>
<pre><code class="language-nix">let minePackages = {
  wood = { ... }: ...;
  stick = { wood, ... }: ...;
  planks = { wood, ... }: ...;
  ...
}
in
nixpkgs.callPackage minePackages pickaxe {}
</code></pre>
<p>The <code>nixpkgs.callPackage</code> automagically inspects the function arguments
as dependencies in the package set, and construct a dependency graph
that connects all packages with their dependencies. If this succeeds
we get a Nix derivation with the dependency derivations provided
to our partial package.</p>
<h3><a class="header" href="#dependency-injection" id="dependency-injection">Dependency Injection</a></h3>
<p><code>callPackage</code> is essentially a dependency injection pattern, where
components can specify what they need without hardcoding the
reference. This allows dependencies to be <em>overridden</em> before
the <code>callPackage</code> is called.</p>
<p>Using functional programming techniques, it is relatively trivial
to compose partial package functions so that dependencies can
be overridden either locally or globally. For example, nixpkgs
use the
<a href="https://nixos.org/guides/nix-pills/override-design-pattern.html">override</a>
pattern to allow dependencies of a package be overridden.</p>
<p>While functional programming makes it easy to override dependencies,
it does not make it easy to <em>inspect</em> the dependency graph to find
out what is overridden. This is the downside of composing using
closures as blackboxes, as compared to composing ADTs
(algebraic data types) as whiteboxes.</p>
<p>Because of this, heavy usage of <code>callPackage</code> and <code>override</code> may impact
readability and maintainability. Readers of a Nix code base may no longer
be able to statically infer which final versions of dependencies are
linked to a package.</p>
<h2><a class="header" href="#haskellnix" id="haskellnix">Haskell.nix</a></h2>
<p>There is an alternative approach to managing Haskell dependencies
using <a href="https://github.com/input-output-hk/haskell.nix">Haskell.nix</a>.
Unlike the mono-versioned Haskell packages in nixpkgs, Haskell.nix
gives more flexibilities and allows interoperability with the
multi-versioned approach of package management with cabal.</p>
<p>As we will see in the next chapter, the multi-versioned approach
of Haskell.nix makes it much easier to add bleeding-edge dependencies
from Hackage. Haskell.nix also offers many other features, such as
cross compiling Haskell packages.</p>
<p>The biggest hurdle of adopting Haskell.nix is unfortunately to
properly add Haskell.nix as a dependency in your Nix project.
From the first section of the
<a href="https://github.com/input-output-hk/haskell.nix#help-something-isnt-working">project readme</a>:</p>
<blockquote>
<p><strong>Help! Something isn't working</strong></p>
<p>The #1 problem that people have when using haskell.nix is that they find themselves building GHC. This should not happen, but you must follow the haskell.nix setup instructions properly to avoid it. If you find this happening to you, please check that you have followed the
<a href="https://input-output-hk.github.io/haskell.nix/tutorials/getting-started/#setting-up-the-binary-cache">getting started instructions</a>
and consult the corresponding
<a href="https://input-output-hk.github.io/haskell.nix/troubleshooting/#why-am-i-building-ghc">troubleshooting section</a>.</p>
</blockquote>
<p>As mentioned, the most important step to start using Haskell.nix is to
add the <code>hydra.iohk.io</code> Nix cache to your <code>~/.config/nix/nix.conf</code>:</p>
<pre><code>trusted-public-keys = [...] hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ= [...]
substituters = [...] https://hydra.iohk.io [...]
</code></pre>
<h3><a class="header" href="#haskellnix-based-derivation" id="haskellnix-based-derivation">Haskell.nix-based derivation</a></h3>
<p>Aside from that first hurdle, defining a Haskell.nix-based Nix derivation
is relatively straightforward. First we define a <code>project.nix</code>:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};

  haskell-nix = import sources.&quot;haskell.nix&quot; {};

  nixpkgs = haskell-nix.pkgs;

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = nixpkgs.haskell-nix.cabalProject {
    inherit src;

    compiler-nix-name = &quot;ghc8102&quot;;
  };
in
project
</code></pre>
<p>We use the version of Haskell.nix managed by niv and import it. Here we
also use the version of nixpkgs provided by Haskell.nix, which adds
additional functionalities in <code>nixpkgs.haskell-nix</code>. We then call the
function <code>haskell-nix.pkgs.haskell-nix.cabalProject</code> to define a
cabal-based Haskell.nix project.</p>
<p>We provide the Haskell source code through the <code>src</code> attribute, and
also a <code>compiler-nix-name</code> field to specify the GHC version we want
to use, GHC 8.10.2.</p>
<h3><a class="header" href="#project-outputs" id="project-outputs">Project Outputs</a></h3>
<p>To actually build our Haskell project, we define a <code>default.nix</code> to
build the <code>hello</code> executable we have in our project:</p>
<pre><code class="language-nix">let
  project = import ./project.nix;
in
project.haskell-project.components.exes.hello
</code></pre>
<p>A Haskell.nix project can have multiple derivation outputs for
each cabal component. For our case, we do not have any library
but have one executable named <code>hello</code>. To load that, the executable
is unfortunately located in a long and obscure path
<code>project.haskell-project.components.exes.hello</code>.</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v1/nix/03-haskell.nix/
trace: No index state specified, using the latest index state that we know about (2020-12-04T00:00:00Z)!
these derivations will be built:
  /nix/store/xdpklq1y86h6jw6d8fyw6xwhr93l8g73-haskell-project-exe-hello-0.1.0.0-config.drv
  /nix/store/j0azqvy5iccbfqp6s0gbfwdgjjp8x2ji-haskell-project-exe-hello-0.1.0.0-ghc-8.10.2-env.drv
  /nix/store/mp20hw7kjpqfwqsspjff0h8w8qng8n9d-haskell-project-exe-hello-0.1.0.0.drv
...
/nix/store/yr533l33zrpri7n47lsfm2cih5i0800a-haskell-project-exe-hello-0.1.0.0

$ /nix/store/yr533l33zrpri7n47lsfm2cih5i0800a-haskell-project-exe-hello-0.1.0.0/bin/hello
Hello, Haskell!
</code></pre>
<h1><a class="header" href="#version-conflicts-in-haskell-dependencies" id="version-conflicts-in-haskell-dependencies">Version Conflicts in Haskell Dependencies</a></h1>
<p>In the previous chapter we have created a trivial Haskell project with no
dependency other than <code>base</code>. Let's look at what happen when our Haskell
project have some dependencies, which happen to conflict with the
dependencies available in <code>nixpkgs</code>.</p>
<p>We first define a new Haskell project,
<a href="05-package-management/./haskell-project-v2/haskell/haskell-project.cabal">haskell-project-v2</a>:</p>
<pre><code>cabal-version:       2.4
name:                haskell-project
version:             0.1.0.0
license:             ISC
build-type:          Simple

executable hello
  main-is:             Main.hs
  build-depends:       base &gt;=4.13
                     , yaml == 0.11.3.0
  default-language:    Haskell2010
</code></pre>
<p>We add a new dependency <code>yaml</code> and explicitly requiring version <code>0.11.3.0</code>.
At the time of writing, the latest version of <code>yaml</code> available on
<a href="https://hackage.haskell.org/package/yaml">Hackage</a> is <code>0.11.5.0</code>.
However let's pretend there are
<a href="https://github.com/snoyberg/yaml/issues/173">breaking changes</a>
in <code>0.11.5.0</code>, and we only support <code>0.11.3.0</code>.</p>
<h2><a class="header" href="#nixpkgs" id="nixpkgs">Nixpkgs</a></h2>
<p>Let's try to follow our previous approach to define our Haskell derivation
using <code>callCabal2nix</code>. If we do that and try to build it, we would
run into an error:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v2/nix/01-nixpkgs-conflict/
building '/nix/store/3gab06pwqjc16wdqhj5akxk21g1z0qnx-cabal2nix-haskell-project.drv'...
these derivations will be built:
  /nix/store/242x69pl2la3lb201qd57rghisrwclpy-haskell-project-0.1.0.0.drv
building '/nix/store/242x69pl2la3lb201qd57rghisrwclpy-haskell-project-0.1.0.0.drv'...
...
Setup: Encountered missing or private dependencies:
yaml ==0.11.3.0

builder for '/nix/store/242x69pl2la3lb201qd57rghisrwclpy-haskell-project-0.1.0.0.drv' failed with exit code 1
error: build of '/nix/store/242x69pl2la3lb201qd57rghisrwclpy-haskell-project-0.1.0.0.drv' failed
</code></pre>
<p>Why is that so?</p>
<p>If we try to enter Nix shell, it will still succeed. But if we try to build
our Haskell project in Nix shell, we will find out that the package <code>yaml</code>
has to be explicitly built by cabal:</p>
<pre><code class="language-bash">$ nix-shell 05-package-management/haskell-project-v2/nix/01-nixpkgs-conflict/shell.nix

[nix-shell]$ cd 05-package-management/haskell-project-v2/haskell/

[nix-shell]$ cabal --dry-run build all
Resolving dependencies...
Build profile: -w ghc-8.10.2 -O1
In order, the following would be built (use -v for more details):
 - yaml-0.11.3.0 (lib) (requires build)
 - haskell-project-0.1.0.0 (exe:hello) (first run)
</code></pre>
<h2><a class="header" href="#problem-with-mono-versioning" id="problem-with-mono-versioning">Problem with Mono-versioning</a></h2>
<p>If we look into
<a href="https://raw.githubusercontent.com/NixOS/nixpkgs/c1e5f8723ceb684c8d501d4d4ae738fef704747e/pkgs/development/haskell-modules/hackage-packages.nix">nixpkgs source code</a>,
we can in fact see that the version of <code>yaml</code> available in nixpkgs is the latest,
<code>0.11.5.0</code>.</p>
<p>As discussed earlier, with the mono-versioning approach by nixpkgs, there is
exactly one version of each package available. Mono-versioning conflicts
can happen when we need packages that are either older or newer than the version
provided by nixpkgs.</p>
<p>In theory we could switch to a version of nixpkgs that has <code>yaml-0.11.3.0</code>,
however we would then have to buy into the versions of other Haskell packages
available at that time.</p>
<h2><a class="header" href="#overriding-versions" id="overriding-versions">Overriding Versions</a></h2>
<p>Nixpkgs provides a workaround for mono-versioning conflicts, by using the
<a href="https://nixos.org/guides/nix-pills/override-design-pattern.html">override pattern</a>.
We can override the version of <code>yaml</code> to the one we want as follows:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsLib = nixpkgs.haskell.lib;
  hsPkgs-original = nixpkgs.haskell.packages.ghc8102;

  hsPkgs = hsPkgs-original.override {
    overrides = hsPkgs-old: hsPkgs-new: {
      yaml = hsPkgs-new.callHackage
        &quot;yaml&quot; &quot;0.11.3.0&quot; {};
    };
  };

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<p>Essentially, we refer to the original haskell package set provided as
<code>hsPkgs-original</code>, and we call <code>hsPkgs-original.override</code> to produce
a new package set <code>hsPkgs</code> with <code>yaml</code> overridden to <code>0.11.3.0</code>.</p>
<p>Using <code>callHackage</code>, we can fetch the version of <code>yaml</code> from the
Hackage snapshot in nixpkgs. With that we can just provide the
string <code>&quot;0.11.3.0&quot;</code> to specify the version that we want. Note
however that this only works if the version can be found in the
given Hackage snapshot, which may be outdated over time.</p>
<p>An issue with overriding dependencies this way is that the override
affects the entire Haskell package set. This means that all other
Haskell packages that depend on <code>yaml</code> will also get <code>0.11.3.0</code>
instead of <code>0.11.5.0</code>. As a result, this may have the unintended
ripple effect of breaking other Haskell packages that we depends
on.</p>
<h2><a class="header" href="#building-overridden-package" id="building-overridden-package">Building Overridden Package</a></h2>
<p>If we try to build our Haskell derivation with overridden <code>yaml</code>,
it would work this time:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v2/nix/02-nixpkgs-override/
these derivations will be built:
  /nix/store/l0v04zz36b5s5r3qc2jisvggyc0gkj5w-remove-references-to.drv
  /nix/store/bg5z6b7m24fxqn8qq2l2w8c0w30wkbp3-yaml-0.11.3.0.drv
  /nix/store/p5sr404mzr8bnqqprv72lxczdr9cnnim-haskell-project-0.1.0.0.drv
...
/nix/store/0m0mr11ncii3z4zkn9z0xkwk4nswprqm-haskell-project-0.1.0.0
</code></pre>
<p>We can also enter the Nix shell to verify that this time, cabal will
not try to build <code>yaml</code> for us:</p>
<pre><code class="language-bash">$ nix-shell 05-package-management/haskell-project-v2/nix/02-nixpkgs-override/shell.nix

[nix-shell]$ cd 05-package-management/haskell-project-v2/haskell/

[nix-shell]$ cabal --dry-run build all
Resolving dependencies...
Build profile: -w ghc-8.10.2 -O1
In order, the following would be built (use -v for more details):
 - haskell-project-0.1.0.0 (exe:hello) (first run)
</code></pre>
<h2><a class="header" href="#haskellnix-1" id="haskellnix-1">Haskell.nix</a></h2>
<p>In comparison with the mono-versioned nixpkgs, Haskell.nix is much more flexible
in allowing any version of Haskell packages that are supported by cabal.
So we can leave the Nix project unchanged and still build it successfully:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v2/nix/03-haskell.nix/
trace: No index state specified, using the latest index state that we know about (2020-12-04T00:00:00Z)!
building '/nix/store/v4pf9jffq0dh6xang25qviwb77947s7s-plan-to-nix-pkgs.drv'...
Using index-state 2020-12-04T00:00:00Z
Warning: The package list for 'hackage.haskell.org-at-2020-12-04T000000Z' is
18603 days old.
Run 'cabal update' to get the latest list of available packages.
Warning: Requested index-state2020-12-04T00:00:00Z is newer than
'hackage.haskell.org-at-2020-12-04T000000Z'! Falling back to older state
(2020-12-03T20:14:57Z).
Resolving dependencies...
Build profile: -w ghc-8.10.2 -O1
In order, the following would be built (use -v for more details):
 - base-compat-0.11.2 (lib) (requires download &amp; build)
 - base-orphans-0.8.3 (lib) (requires download &amp; build)
 ...
 - aeson-1.5.4.1 (lib) (requires download &amp; build)
 - yaml-0.11.3.0 (lib) (requires download &amp; build)
 - haskell-project-0.1.0.0 (exe:hello) (first run)
these derivations will be built:
these derivations will be built:
...
  /nix/store/y8vbr0b6y8bzgmadj0rfjp3d2rzx5wgs-yaml-lib-yaml-0.11.3.0-config.drv
  /nix/store/fhmib5kqsxl82r1z23mm59njw2dn0c8v-yaml-lib-yaml-0.11.3.0-ghc-8.10.2-env.drv
  /nix/store/j837v0cxk9dxqpxfjfngii007hq8wn3w-yaml-lib-yaml-0.11.3.0.drv
  /nix/store/nxwvfjaj40adyq002khld7ngnq3wggn7-haskell-project-exe-hello-0.1.0.0-config.drv
  /nix/store/y27wbd58f5d1k3lzbzpr5qcc4pgqrxg2-haskell-project-exe-hello-0.1.0.0-ghc-8.10.2-env.drv
  /nix/store/b4i7xhnha8007zqxd4gidsf7xyy338an-haskell-project-exe-hello-0.1.0.0.drv
...
/nix/store/phm2jk6xnvxsgp640r66cwgipc62kbc5-haskell-project-exe-hello-0.1.0.0

$ /nix/store/phm2jk6xnvxsgp640r66cwgipc62kbc5-haskell-project-exe-hello-0.1.0.0/bin/hello
Hello, Haskell!
</code></pre>
<h1><a class="header" href="#transitive-haskell-version-conflicts" id="transitive-haskell-version-conflicts">Transitive Haskell Version Conflicts</a></h1>
<p>Let's look at another example of nixpkgs-based Haskell project, where version
conflicts are propagated to transitive dependencies.</p>
<p>We have another Haskell project,
<a href="05-package-management/./haskell-project-v3/haskell/haskell-project.cabal">haskell-project-v3</a>
with a dependency on the latest <code>QuickCheck-2.14.2</code>:</p>
<pre><code>cabal-version:       2.4
name:                haskell-project
version:             0.1.0.0
license:             ISC
build-type:          Simple

executable hello
  main-is:             Main.hs
  build-depends:       base &gt;=4.13
                     , QuickCheck == 2.14.2
  default-language:    Haskell2010
</code></pre>
<p>Now try building the project with the default <code>callCabal2nix</code>:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsPkgs = nixpkgs.haskell.packages.ghc8102;

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<p>We should see that the building failed, because the
<a href="https://raw.githubusercontent.com/NixOS/nixpkgs/c1e5f8723ceb684c8d501d4d4ae738fef704747e/pkgs/development/haskell-modules/hackage-packages.nix">version of nixpkgs</a>
we are using only has <code>QuickCheck-2.13.2</code> in it.</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v3/nix/01-nixpkgs-conflict
building '/nix/store/12qzjbk3514sj9v4j99brbxr4b83bzy5-cabal2nix-haskell-project.drv'...
installing
these derivations will be built:
  /nix/store/d5jyli1v9y12il9wyzs5x6gyx6q68gig-haskell-project-0.1.0.0.drv
...
Setup: Encountered missing or private dependencies:
QuickCheck ==2.14.2

builder for '/nix/store/d5jyli1v9y12il9wyzs5x6gyx6q68gig-haskell-project-0.1.0.0.drv' failed with exit code 1
error: build of '/nix/store/d5jyli1v9y12il9wyzs5x6gyx6q68gig-haskell-project-0.1.0.0.drv' failed
</code></pre>
<h2><a class="header" href="#using-latest-hackage-package" id="using-latest-hackage-package">Using Latest Hackage Package</a></h2>
<p>Now we try using the override pattern in the previous chapter to override the
version of <code>QuickCheck</code>:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsLib = nixpkgs.haskell.lib;
  hsPkgs-original = nixpkgs.haskell.packages.ghc8102;

  hsPkgs = hsPkgs-original.override {
    overrides = hsPkgs-old: hsPkgs-new: {
      QuickCheck = hsPkgs-new.callHackage &quot;QuickCheck&quot; &quot;2.14.2&quot; {};
    };
  };

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<p>This time the build actually failed with another error:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v3/nix/01-nixpkgs-conflict
building '/nix/store/12qzjbk3514sj9v4j99brbxr4b83bzy5-cabal2nix-haskell-project.drv'...
installing
these derivations will be built:
  /nix/store/d5jyli1v9y12il9wyzs5x6gyx6q68gig-haskell-project-0.1.0.0.drv
...
Configuring haskell-project-0.1.0.0...
CallStack (from HasCallStack):
  $, called at libraries/Cabal/Cabal/Distribution/Simple/Configure.hs:1024:20 in Cabal-3.2.0.0:Distribution.Simple.Configure
  configureFinalizedPackage, called at libraries/Cabal/Cabal/Distribution/Simple/Configure.hs:477:12 in Cabal-3.2.0.0:Distribution.Simple.Configure
  configure, called at libraries/Cabal/Cabal/Distribution/Simple.hs:625:20 in Cabal-3.2.0.0:Distribution.Simple
  confHook, called at libraries/Cabal/Cabal/Distribution/Simple/UserHooks.hs:65:5 in Cabal-3.2.0.0:Distribution.Simple.UserHooks
  configureAction, called at libraries/Cabal/Cabal/Distribution/Simple.hs:180:19 in Cabal-3.2.0.0:Distribution.Simple
  defaultMainHelper, called at libraries/Cabal/Cabal/Distribution/Simple.hs:116:27 in Cabal-3.2.0.0:Distribution.Simple
  defaultMain, called at Setup.hs:2:8 in main:Main
Setup: Encountered missing or private dependencies:
QuickCheck ==2.14.2

builder for '/nix/store/d5jyli1v9y12il9wyzs5x6gyx6q68gig-haskell-project-0.1.0.0.drv' failed with exit code 1
error: build of '/nix/store/d5jyli1v9y12il9wyzs5x6gyx6q68gig-haskell-project-0.1.0.0.drv' failed
soares@soares-workstation:~/scrive/nix-workshop/code$ nix-build 05-package-management/haskell-project-v3/nix/02-nixpkgs-not-found
building '/nix/store/ybvimf0jbsbx997588kbipkpbq97iv3d-all-cabal-hashes-component-QuickCheck-2.14.2.drv'...
tar: */QuickCheck/2.14.2/QuickCheck.json: Not found in archive
tar: */QuickCheck/2.14.2/QuickCheck.cabal: Not found in archive
tar: Exiting with failure status due to previous errors
builder for '/nix/store/ybvimf0jbsbx997588kbipkpbq97iv3d-all-cabal-hashes-component-QuickCheck-2.14.2.drv' failed with exit code 2
cannot build derivation '/nix/store/73pfc98xfaj7l818nznr8r4gbls5xmls-cabal2nix-QuickCheck-2.14.2.drv': 1 dependencies couldn't be built
error: build of '/nix/store/73pfc98xfaj7l818nznr8r4gbls5xmls-cabal2nix-QuickCheck-2.14.2.drv' failed
(use '--show-trace' to show detailed location information)
</code></pre>
<p>What happened this time? If we check the
<a href="https://github.com/NixOS/nixpkgs/commit/c1e5f8723ceb684c8d501d4d4ae738fef704747e">commit log</a>
of our nixpkgs version, we will find out that the nixpkgs we have is commited
on 9 November 2020, but on
<a href="https://hackage.haskell.org/package/QuickCheck">Hackage</a>
<code>QuickCheck-2.14.2</code> is only released on 14 November 2020.</p>
<h2><a class="header" href="#hackage-index-in-nixpkgs" id="hackage-index-in-nixpkgs">Hackage Index in Nixpkgs</a></h2>
<p>Inside the override call, when we call <code>callHackage</code> to get a Haskell package
from Hackage, we are really just downloading the Haskell source from Hackage
based on the snapshot cached in nixpkgs.</p>
<p>Recall from the principal of reproducibility, with just a version number, there
is no way Nix can tell if we will always get the exact same source code from
Hackage every time a source code is requested. In theory the
<code>QuickCheck-2.14.2</code> we fetched today may be totally different from the
<code>QuickCheck-2.14.2</code> we fetch tomorrow, or when it is fetched by someone else.</p>
<p>Nixpkgs solves this by computing the content hash of every Hackage package
at the time of snapshot. So we can know for sure that the same Hackage pacakge
we fetch with the same nixpkgs will always give back the same result.
Nixpkgs also does implicit patching on some Hackage package, if their
default configuration breaks.</p>
<p>One option for us may be to simply update to the latest version of nixpkgs
so that it contains <code>QuickCheck-2.14.2</code>. However nixpkgs do not immediately
update the Hackage snapshot every time a new Haskell pacakge is published.
Rather there is usually 1~2 weeks lag as the Haskell packages are updated
in bulk. So we can't rely on that if we want to use a Haskell package
just published an hour ago.</p>
<p>Furthermore, updating nixpkgs also means all other packages in nixpkgs
also being updated. That may result in breaking some of our own Nix
packages.</p>
<p>In theory we could use a stable Nix channel like <code>nixos-20.09</code>
instead of <code>nixpkgs-unstable</code> so that it is safer to update nixpkgs.
But stability always needs tradeoff with rapid releases,
so it will take even longer before the Hackage snapshot update
is propagated there.</p>
<h2><a class="header" href="#callhackagedirect" id="callhackagedirect">CallHackageDirect</a></h2>
<p>If we want to get the latest Hackage package beyond what is available
in nixpkgs, we can instead use <code>callHackageDirect</code> to directly
download the package from Hackge, skipping nixpkgs entirely:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsLib = nixpkgs.haskell.lib;
  hsPkgs-original = nixpkgs.haskell.packages.ghc8102;

  hsPkgs = hsPkgs-original.override {
    overrides = hsPkgs-old: hsPkgs-new: {
      QuickCheck = hsPkgs-new.callHackageDirect {
        pkg = &quot;QuickCheck&quot;;
        ver = &quot;2.14.2&quot;;
        sha256 = &quot;0rx4lz5rj0s1v451cq6qdxhilq4rv9b9lnq6frm18h64civ2pwbq&quot;;
      } {};
    };
  };

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<p><code>callHackageDirect</code> works similarly to other ways of fetching source code,
such as <code>builtins.fetchTarball</code> and <code>builtins.fetchgit</code>. In fact,
we can also override a Haskell dependency with a GitHub commit or
source tarball. Here we just need to provide an additional information,
which is the SHA256 checksum of the package.</p>
<p>There is currently straightforward way to compute the hash, but we can
first supply a dummy hash such as
<code>0000000000000000000000000000000000000000000000000000</code>,
then copy the correct hash from the hash mismatch error when
the derivation is built.</p>
<h2><a class="header" href="#transitive-conflicts" id="transitive-conflicts">Transitive Conflicts</a></h2>
<p>If we try to build it this time however, we are greeted with another error:</p>
<pre><code class="language-bash">$ nix-build 05-package-management/haskell-project-v3/nix/03-nixpkgs-transitive-deps
these derivations will be built:
  /nix/store/6my008rqdjb9kbmx0pr80c0zc0fyqqyh-QuickCheck-2.14.2.drv
  /nix/store/lvclw4q2jmk89v5ppkfw3mr72qb8ch2d-haskell-project-0.1.0.0.drv
building '/nix/store/6my008rqdjb9kbmx0pr80c0zc0fyqqyh-QuickCheck-2.14.2.drv'...
...
Configuring QuickCheck-2.14.2...
CallStack (from HasCallStack):
  $, called at libraries/Cabal/Cabal/Distribution/Simple/Configure.hs:1024:20 in Cabal-3.2.0.
  ...
  defaultMain, called at Setup.lhs:8:10 in main:Main
Setup: Encountered missing or private dependencies:
splitmix ==0.1.*

builder for '/nix/store/6my008rqdjb9kbmx0pr80c0zc0fyqqyh-QuickCheck-2.14.2.drv' failed with exit code 1
cannot build derivation '/nix/store/lvclw4q2jmk89v5ppkfw3mr72qb8ch2d-haskell-project-0.1.0.0.drv': 1 dependencies couldn't be built
error: build of '/nix/store/lvclw4q2jmk89v5ppkfw3mr72qb8ch2d-haskell-project-0.1.0.0.drv' failed
</code></pre>
<p>So it turns out that <code>QuickCheck-2.14.2</code> depends on <code>splitmix ==0.1.*</code>, but nixpkgs only
have <code>splitmix-0.0.5</code>, despite <code>splitmix-0.1</code> has been released since May 2020.</p>
<p>We can see this as the effect of transitive dependency update. If <code>splitmix</code> is upgraded
to version <code>0.1</code>, it will break many packages that directly depend on it, which
in turns breaks other packages that indirectly depend on it. With nixpkgs's
mono-versioning approach, there is no easy way around this other than upgrading
all affecting packages at once, or upgrading none of them. Mono-versioning
is hard!</p>
<p>Still, we can workaround this by overriding <code>splitmix</code> as well:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsLib = nixpkgs.haskell.lib;
  hsPkgs-original = nixpkgs.haskell.packages.ghc8102;

  hsPkgs = hsPkgs-original.override {
    overrides = hsPkgs-old: hsPkgs-new: {
      QuickCheck = hsPkgs-new.callHackageDirect {
        pkg = &quot;QuickCheck&quot;;
        ver = &quot;2.14.2&quot;;
        sha256 = &quot;0rx4lz5rj0s1v451cq6qdxhilq4rv9b9lnq6frm18h64civ2pwbq&quot;;
      } {};

      splitmix = hsPkgs-new.callHackage
        &quot;splitmix&quot; &quot;0.1.0.3&quot; {};
    };
  };

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<h2><a class="header" href="#infinite-recursion" id="infinite-recursion">Infinite Recursion</a></h2>
<p>If we build this, we once again get another error: the infamous infinite recursion
error:</p>
<pre><code class="language-bash">$ nix-build --show-trace 05-package-management/haskell-project-v3/nix/04-nixpkgs-infinite-recursion/
error: while evaluating the attribute 'buildInputs' of the derivation 'haskell-project-0.1.0.0' at /nix/store/kk346951sg2anjjh8cgfbmrijg983z5q-nixpkgs-src/pkgs/development/haskell-modules/generic-builder.nix:291:3:
while evaluating the attribute 'propagatedBuildInputs' of the derivation 'QuickCheck-2.14.2' at /nix/store/kk346951sg2anjjh8cgfbmrijg983z5q-nixpkgs-src/pkgs/development/haskell-modules/generic-builder.nix:291:3:
while evaluating the attribute 'buildInputs' of the derivation 'splitmix-0.1.0.3' at /nix/store/kk346951sg2anjjh8cgfbmrijg983z5q-nixpkgs-src/pkgs/development/haskell-modules/generic-builder.nix:291:3:
while evaluating the attribute 'propagatedBuildInputs' of the derivation 'async-2.2.2' at /nix/store/kk346951sg2anjjh8cgfbmrijg983z5q-nixpkgs-src/pkgs/development/haskell-modules/generic-builder.nix:291:3:
while evaluating the attribute 'buildInputs' of the derivation 'hashable-1.3.0.0' at /nix/store/kk346951sg2anjjh8cgfbmrijg983z5q-nixpkgs-src/pkgs/development/haskell-modules/generic-builder.nix:291:3:
infinite recursion encountered, at undefined position
</code></pre>
<p>So <code>QuickCheck</code> depends on <code>splitmix</code>, but <code>splitmix</code> tests also indirectly depend on
<code>QuickCheck</code>, causing a cyclic dependency. Unfortunately the callPackage
pattern do not have a way to deal with cyclic dependencies, so we have to
manually find ways around it.</p>
<p>Fortunately in this case, it is simple to avoid it by no running unit tests on
<code>splitmix</code>:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};
  nixpkgs = import sources.nixpkgs {};

  hsLib = nixpkgs.haskell.lib;
  hsPkgs-original = nixpkgs.haskell.packages.ghc8102;

  hsPkgs = hsPkgs-original.override {
    overrides = hsPkgs-old: hsPkgs-new: {
      QuickCheck = hsPkgs-new.callHackageDirect {
        pkg = &quot;QuickCheck&quot;;
        ver = &quot;2.14.2&quot;;
        sha256 = &quot;0rx4lz5rj0s1v451cq6qdxhilq4rv9b9lnq6frm18h64civ2pwbq&quot;;
      } {};

      splitmix = hsLib.dontCheck
        (hsPkgs-new.callHackage
          &quot;splitmix&quot; &quot;0.1.0.3&quot; {});
    };
  };

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = hsPkgs.callCabal2nix &quot;haskell-project&quot; src;
in
hsPkgs.callPackage project {}
</code></pre>
<p>Now our package finally builds.</p>
<h2><a class="header" href="#haskellnix-2" id="haskellnix-2">Haskell.nix</a></h2>
<p>In comparison, there is no manual intervention needed for Haskell.nix-based
derivation:</p>
<pre><code class="language-nix">let
  sources = import ../sources.nix {};

  haskell-nix = import sources.&quot;haskell.nix&quot; {};

  nixpkgs = haskell-nix.pkgs;

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = nixpkgs.haskell-nix.cabalProject {
    inherit src;

    compiler-nix-name = &quot;ghc8102&quot;;
  };
in
project
</code></pre>
<p>Hoepfully this shows why we prefer to use Haskell.nix, especially if we
want it to work the same way as cabal and get the latest Haskell packages
from Hackage.</p>
<h1><a class="header" href="#multi-versioned-haskell-packages" id="multi-versioned-haskell-packages">Multi-versioned Haskell Packages</a></h1>
<p>As we seens in the previous chapters, the mono-versioned Haskell packages
provided by nixpkgs do not always provide the exact versions of Haskell
packages that we need. When version conflicts happen, it often require
manual intervention, because there is no mechanism to automatically
resolve the new set of dependency versions based on custom requirements.</p>
<p>In comparison, package managers like cabal-install are built with
multi-versioned Haskell packages in mind. We can give various
requirements of our dependencies to cabal by specifying version
bounds. If a solution exists, cabal can automatically generate a
dependency graph for us.</p>
<h2><a class="header" href="#haskellnix-3" id="haskellnix-3">Haskell.nix</a></h2>
<p>Haskell.nix takes multi-versioned approach toward managing Haskell
packages in Nix. It does so by making use of cabal-install to
resolve the dependency graph, and converting it into Nix expressions.</p>
<p>Since Haskell.nix uses cabal-install for the actual package management,
it can usually work out of the box for existing cabal-based Haskell
projects.</p>
<p>Nevertheless, Cabal offers a wide range of features, some of which
are not currently well supported by Haskell.nix. Because of this,
it is important to understand how Haskell.nix works internally.
This would help us understand why certain limitations are present
in Haskell.nix.</p>
<p>Haskell.nix also provides other mode of Haskell development in Nix,
such as Stack-based Haskell projects. However in this chapter we
will focus only on using Haskell.nix for cabal projects.</p>
<h2><a class="header" href="#hackage-index" id="hackage-index">Hackage Index</a></h2>
<p>To understand how Haskell.nix resolves dependencies, we have to first
understand how Cabal resolves dependencies. Recall from the chapter
<a href="05-package-management/./01-dependency-management.html">Dependency Management</a> that for
a package manager to resolve dependencies, it has to run the
dependency resolution algorithm against the state of a package
registry.</p>
<p>For the case of Cabal, the dependency resolution is done against
the <a href="https://hackage.haskell.org">Hackage</a> registry.
More specifically, Cabal resolves the dependencies by downloading
the <a href="https://hackage.haskell.org/01-index.tar.gz">entire state</a>
of the Hackage index to your local machine.</p>
<p>Every time new packages are added to Hackage, a new Hackage index
snapshot is generated, and the entire index has to be re-downloaded.
(Technically, the update is incremental with append-only update to
the snapshot. However this relies on explicit HTTP caching mechanism
to work.)</p>
<p>Currently the Hackage index snapshot takes about 100 MiB after
compression. Furthermore the official Hackage bandwidth is pretty
low and do not always stay available. Because of this, it can often
take a long time to update cabal, especially when running it for
the first time.</p>
<p>When we build Haskell projects with <code>cabal</code>, the local Hackage
index is not updated automatically. Instead we have to manually
run <code>cabal update</code> to update the local Hackage index. As a result,
it is a common problem that a new Haskell package is published
to Hackage, but it cannot be found in local builds because
the local index is not updated.</p>
<h2><a class="header" href="#accessing-hackage-index-inside-nix" id="accessing-hackage-index-inside-nix">Accessing Hackage Index Inside Nix</a></h2>
<p>Since Haskell.nix uses Cabal to resolve the dependencies inside
Nix, it needs to download and provide the Hackage snapshot
inside of a Nix build.</p>
<p>By default, Cabal downloads the Hackage snapshot into
<code>~/.cabal/packages</code>. However since there is no home directory
inside a Nix build, we need to put it somewhere local.
This can be done by specifying a <code>--remote-repo-cache</code>
option when running Cabal.</p>
<p>Even so, the next challenge is that we need to download
the Hackage snapshot, and save it to the Nix store.
The SHA256 checksum of the Hackage snapshot is also
needed, so that Nix can be sure that all Nix builds are using the exact
version of Hackage snapshot.</p>
<p>Fortunately Haskell.nix takes care of all these details for us. However this
comes at a cost: Haskell.nix needs to regularly update and convert the
Hackage snapshot into Nix expressions.</p>
<p>In fact, Haskell.nix manages this through the
<a href="https://github.com/input-output-hk/hackage.nix">Hackage.nix</a> project.
It triggers regular CI builds to update to the latest Hackage snapshot,
and save the result as Nix expressions. Haskell.nix itself is also
regularly updated, to update the Hackage snapshot through
updating the version of Hackage.nix used in Haskell.nix.</p>
<p>Regardless, the state update do not run continuously, but rather
usually once every day. There can be up to a few days delay
for the Hackage snapshot to be included in Haskell.nix.
This also means that when a new Haskell package is published
to Hackage, we cannot always use it immediately in Haskell.nix.</p>
<p>If we really insist on getting the bleeding edge Haskell packages,
a workaround would be that we can maintain our own Hackage snapshot.
Since Hackage.nix is open source, there is no problem doing that.
However this would also adds a lot of overhead, as we would
have to regularly keep up to date our own version of Hackage.nix.
Because of this, we recommend readers to be patient and wait for
few days for a new Haskell packge to become available in Haskell.nix.</p>
<h2><a class="header" href="#freezing-hackage-index" id="freezing-hackage-index">Freezing Hackage Index</a></h2>
<p>The Hackage index at hackage.haskell.org is constantly updated, and there is
no straightforward way to go back in time and get the old state of Hackage
at a time in the past.</p>
<p>This can cause issue when we try to download the Hackage snapshot from Nix.
To ensure reproducibility, the downloaded <code>01-index.tar.gz</code> is supposed
to have the exact same content for everyone by checking the SHA256
checksum. But since the Hackage index keeps changing, we cannot ask
Nix to just download the index from the URL.</p>
<p>As a workaround, Hackage instead guarantees that the index state is
updated in append-only mode. With this Haskell.nix uses a workaround
to <em>truncate</em> the downloaded index with a known length of the
snapshot at a particular time during fetching. This helps make sure
that when Nix finally sees the index archive, the content is exactly
the same regardless of when the code is evaluated.</p>
<p>Nevertheless, this workaround is one part of the complexity in Haskell.nix.
In the daily update to Hackage.nix, it has to regularly check the new
length of the latest Hackage index, while keeping the old lengths for
each day in the past. As a <code>.tar.gz</code> file, the format is opaque, and
it needs to rely on the obscure interaction of Hackage with the file
compression to create a reproducible index snapshot.</p>
<h2><a class="header" href="#source-repository-package" id="source-repository-package">Source Repository Package</a></h2>
<p>Haskell.nix also allows Haskell packages to be provided outside of Hackage.
This can be done by adding
<a href="https://cabal.readthedocs.io/en/3.4/cabal-project.html#specifying-packages-from-remote-version-control-locations"><code>source-repository-package</code></a>
fields in your cabal.project file. Haskell.nix automatically takes into
consideration these fields when resolving the depdendencies.</p>
<p>One additional detail that is needed when using <code>source-repository-package</code>
with Haskell.nix is that you may optionally needs to add the SHA256
checksum of the Haskell package with a <code>--sha256</code> comment line. More details
<a href="https://input-output-hk.github.io/haskell.nix/tutorials/source-repository-hashes/#cabalproject">here</a>.</p>
<h2><a class="header" href="#resolving-dependencies" id="resolving-dependencies">Resolving Dependencies</a></h2>
<p>We have learned <a href="05-package-management/../04-derivations/03-fibonacci.html">earlier</a> that
evaluation-time dependencies can cause various issues in Nix. However
Haskell.nix uses evaluation-time dependency, or more specifically
Import From Derivation (IFD), to resolve the dependency graph
of our Haskell projects.</p>
<p>To understand why IFD is needed, we need to first look at how Cabal
resolves the dependencies, and where it stores the dependency graph.</p>
<p>We can ask Cabal to resolve the dependencies of our Haskell project
by running <code>cabal configure</code>. Inside this command, Cabal will read the
cabal.project and .cabal file, read the local Hackage snapshot,
and try to come out with a dependency graph as the solution. When successful,
cabal stores the result locally in the <code>dist-newstyle/cache</code> directory.</p>
<p>Inside the <code>dist-newstyle/cache</code> directory, there is a <code>plan.json</code> file
which contains the dependency graph that third party tools such as
Haskell.nix can use to extract the result. There are libraries such as
<a href="https://hackage.haskell.org/package/cabal-plan">cabal-plan</a> that are available,
which Haskell.nix uses to parse the dependency graph.</p>
<p>Now remember that to build a Haskell project with Nix, we need to construct
one or more Nix derivations that encapsulate our project and all its
dependencies. Since a Haskell project contains many dependencies, we want to
define each Haskell package as their own Nix derivation. This way Nix can
parallellize the build for each of our dependencies, and also reuse the build
result if only some of the dependencies changes.</p>
<p>However to construct our derivation, we need to first call <code>cabal configure</code>
to resolve the dependency graph, and then extract the result from <code>plan.json</code>.
In other words, to construct the actual Nix derivation of our project, we need
to first construct another derivation that produces a build plan that tells us
what dependencies are needed.</p>
<h2><a class="header" href="#derivation-plan" id="derivation-plan">Derivation Plan</a></h2>
<p>In Haskell.nix, the build plan that is produced from calling Cabal is called
a <em>plan</em>. The name might be a bit confusing, but essentially
it represents the evaluation-time dependency of a Haskell project, of which the
Nix derivation that needs to be built first before the actual Nix derivation
for the Haskell project can be constructed.</p>
<p>Recall that Nix cannot identify which derivation is an evaluation-time
dependency of another package. This means that if we try to inspect the
derivation for our Haskell project, the derivation for the plan
would never show up there. This also means that the plan
cannot be cached easily.</p>
<p>Haskell.nix exports the plan for a Haskell project in
the <code>plan-nix</code> attribute. We can build this to see how the plan looks like:</p>
<pre><code class="language-bash">$ nix-build -A plan-nix 05-package-management/haskell-project-v3/nix/06-haskell.nix/project.nix
trace: No index state specified, using the latest index state that we know about (2020-12-04T00:00:00Z)!
checking outputs of '/nix/store/5v1835nh26s8dldssz03cysm3aay6d7q-plan-to-nix-pkgs.drv'...
Using index-state 2020-12-04T00:00:00Z
Warning: The package list for 'hackage.haskell.org-at-2020-12-04T000000Z' is
18610 days old.
Run 'cabal update' to get the latest list of available packages.
Warning: Requested index-state2020-12-04T00:00:00Z is newer than
'hackage.haskell.org-at-2020-12-04T000000Z'! Falling back to older state
(2020-12-03T20:14:57Z).
Resolving dependencies...
Build profile: -w ghc-8.10.2 -O1
In order, the following would be built (use -v for more details):
 - splitmix-0.1.0.3 (lib) (requires download &amp; build)
 - random-1.2.0 (lib) (requires download &amp; build)
 - QuickCheck-2.14.1 (lib) (requires download &amp; build)
 - haskell-project-0.1.0.0 (exe:hello) (first run)
/nix/store/pgdqan44d8ky1yz0d687d2nhqsqflc48-plan-to-nix-pkgs

$ cat /nix/store/pgdqan44d8ky1yz0d687d2nhqsqflc48-plan-to-nix-pkgs/default.nix
{
  pkgs = hackage:
    {
      packages = {
        &quot;ghc-prim&quot;.revision = (((hackage.&quot;ghc-prim&quot;).&quot;0.6.1&quot;).revisions).default;
        &quot;mtl&quot;.revision = (((hackage.&quot;mtl&quot;).&quot;2.2.2&quot;).revisions).default;
        &quot;rts&quot;.revision = (((hackage.&quot;rts&quot;).&quot;1.0&quot;).revisions).default;
        &quot;QuickCheck&quot;.revision = (((hackage.&quot;QuickCheck&quot;).&quot;2.14.1&quot;).revisions).default;
        ...
      }
      compiler = {
        version = &quot;8.10.2&quot;;
        nix-name = &quot;ghc8102&quot;;
        packages = {
          &quot;ghc-prim&quot; = &quot;0.6.1&quot;;
          &quot;mtl&quot; = &quot;2.2.2&quot;;
          ...
        }
      }
    }
  ...
}
</code></pre>
<p>We can see that the plan contains quite detailed information on
the exact versions of dependencies that are needed to build our Haskell
project.</p>
<h2><a class="header" href="#caching-plans-with-materialization" id="caching-plans-with-materialization">Caching Plans with Materialization</a></h2>
<p>The dependency resolution algorithm is not a cheap operation to run, especially
in large Haskell projects. This is why Cabal caches the result inside of
<code>dist-newstyle/cache</code> instead of recomputing it every time commands such as
<code>cabal build</code> are called.</p>
<p>In the case of Nix, we know that a Nix build can be cached and reused if there
are no changes in the build inputs. However for the case of a materialized
plan, the result of the plan depends on the input source code of the Haskell
project. This means that every time the source code changes, the plan
needs to be recomputed from scratch.</p>
<p>Furthermore, computing the materialized plan requires a number of dependencies
that are not needed when building the Haskell project itself. On the other
hand, We know that the materialized plan only changes when either the dependencies
list is updated, or when the Hackage index state is updated. So we should be
able to cache the materialized plan so that there is no need for Haskell.nix
to recompute the dependencies all the time.</p>
<p>In Haskell.nix, the act of manually caching the derivation plan is called
<a href="https://input-output-hk.github.io/haskell.nix/tutorials/materialization/"><em>materialization</em></a>.
To put it simply, we can materialize the derivation plan by copying the
build output of the <code>plan-nix</code> derivation and check that into the source
control of the project.</p>
<p>If we already have the plan files cached in version control, we can then
pass the path to the .nix file as the <code>materialized</code> attribute when defining
our Haskell.nix project.</p>
<h2><a class="header" href="#example-materialized-haskell-project" id="example-materialized-haskell-project">Example Materialized Haskell Project</a></h2>
<p>The Nix project
<a href="05-package-management/./haskell-project-v3/nix/07-haskell.nix-materialized">07-haskell.nix-materialized</a>
contains an example Haskell.nix project that provides basic support for
materialization.</p>
<p>As compared to the simplified version, the project.nix has a few more
additional fields passed to Haskell.nix:</p>
<pre><code class="language-nix">{ useMaterialization ? true }:
let
  sources = import ../sources.nix {};

  haskell-nix = import sources.&quot;haskell.nix&quot; {};

  nixpkgs = haskell-nix.pkgs;

  src = builtins.path {
    name = &quot;haskell-project-src&quot;;
    path = ../../haskell;
    filter = path: type:
      let
        basePath = builtins.baseNameOf path;
      in
      basePath != &quot;dist-newstyle&quot;
    ;
  };

  project = nixpkgs.haskell-nix.cabalProject {
    inherit src;

    compiler-nix-name = &quot;ghc8102&quot;;

    index-state = &quot;2020-12-04T00:00:00Z&quot;;

    materialized = if useMaterialization
      then ./plan else null;

    plan-sha256 = if useMaterialization
      then nixpkgs.lib.removeSuffix &quot;\n&quot;
        (builtins.readFile ./plan-hash.txt)
      else null;

    exactDeps = true;
  };
in
project
</code></pre>
<p>The project.nix file is now a function accepting a <code>useMaterialization</code> argument.
If it is set to <code>true</code>, then the materialized plan is passed to Haskell.nix
through the <code>materialized</code> attribute.</p>
<p>We also need to explicitly provide Haskell.nix the version of Hackage snapshot
we want to use, which we hard code to <code>&quot;2020-12-04T00:00:00Z&quot;</code>.</p>
<p>We set the <code>exactDeps</code> option here to <code>true</code>, so that when the materialized
plan is out of sync, we get error when running <code>cabal build</code> inside the Nix shell.</p>
<p>There are also a new <a href="05-package-management/./haskell-project-v3/nix/07-haskell.nix-materialized/plan">plan</a>
directory, a
<a href="05-package-management/./haskell-project-v3/nix/07-haskell.nix-materialized/plan-hash.txt">plan-hash.txt</a>
file, and a
<a href="05-package-management/./haskell-project-v3/nix/07-haskell.nix-materialized/sync-materialized.sh">sync-materialized.sh</a>
script:</p>
<pre><code class="language-nix">#!/usr/bin/env bash

plan=$(nix-build -j4 --no-out-link --arg useMaterialization false -A plan-nix project.nix)

rm -rf plan

cp -r $plan plan

find plan -type d -exec chmod 755 {} \;

nix-hash --base32 --type sha256 plan &gt; plan-hash.txt
</code></pre>
<p>The script <code>sync-materialized.sh</code> creates a Haskell.nix project with
<code>useMaterialization</code> set to <code>false</code>. It then copies the build output of <code>plan-nix</code>
to the <code>plan/</code> directory, and compute the SHA256 hash of the directory and save it to
<code>plan-hash.txt</code>.</p>
<p>As we can see, a Haskell.nix project using materialized plan is a bit more involved.
However the performance trade off of using materialized plan in a large Haskell
project can be significant. The example project template can hopefully
serve as a reference on how to setup a Haskell.nix project with materialization.</p>
<h2><a class="header" href="#syncing-materialized-plan" id="syncing-materialized-plan">Syncing Materialized Plan</a></h2>
<p>When we explicitly cache the materialized plans, there is a risk of the plan
file diverging from the actual Haskell dependencies when the .cabal file is
updated. It can also introduce additional noise in git commits when
dependencies are updated. This can introduce friction in Haskell projects,
as all team members become responsible to update the materialized plans
when the Haskell dependencies are updated.</p>
<p>Checking in dependencies metadata into version control is a common problem
in software projects, particularly Nix projects. As discussed in
<a href="05-package-management/./01-dependency-management.html">Dependency Management</a>, this is a
necessary evil to make sure that our dependencies are reproducible.
Syncing materialized plans can be seen as the same methods as
syncing other dependencies lock files such as <code>cabal.project.freeze</code>
and <code>package-lock.json</code>.</p>
<p>Nevertheless, the current workflow for managing materialization plans
in Haskell.nix is not very convenient, and there are a lot of
improvements that could have been made. We can only hope that
these steps can be improved in future versions of Haskell.nix.</p>
<p>Or perhaps there are better ways of managing Haskell dependencies,
as described in the next chapter.</p>
<h2><a class="header" href="#caching-haskellnix-dependencies" id="caching-haskellnix-dependencies">Caching Haskell.nix Dependencies</a></h2>
<p>One of the downside of multi-versioning approach taken by Haskell.nix
is that it is much more difficult to provide a general Nix cache for
Haskell.nix projects.</p>
<p>When Haskell projects are built using unmodified nixpkgs, there is
usually no need to build any Haskell dependencies at all. Instead
the Haskell packages are downloaded directly from cache.nixos.org.</p>
<p>This is possible thanks to the mono-versioning approach of nixpkgs.
Since there is exactly one version of each package and their
dependencies, the build result of the same dependency can always be
reused for multiple packages. As such, the number of Nix packages
that need to be cached are relatively small, and the default NixOS
cache takes care of caching all of them.</p>
<p>In contrast, in Haskell.nix the dependencies for a package can
change depending on the requirements of its dependents. So instead of
caching one copy of each version of Haskell package, there is
a combinatory explosion of packages to be cached - one for
each possible combination of transitive dependencies for that package
alone.</p>
<p>Because of this, it is common that building a Haskell.nix project also
requires building all the Haskell dependencies. We will discuss about
how to use Cachix to cache such Nix dependencies in the future.</p>
<h1><a class="header" href="#other-package-management-strategies" id="other-package-management-strategies">Other Package Management Strategies</a></h1>
<p>So far we have covered two approaches to managing dependencies in Nix.
Nixpkgs takes a mono-versioning approach by providing exactly one version
of each package in a particular version of nixpkgs. In contrast, Haskell.nix
captures the entire Hackage snapshot and uses Cabal to resolve the
dependencies with the plan derivation being an evaluation-time Nix dependency.</p>
<p>However these two are not the only approaches to managing dependencies
in Nix. In fact, other languages like Node.js and Rust have come out with
an alternative approach, which is much closer to generating traditional
package lock files.</p>
<h2><a class="header" href="#size-of-package-registry" id="size-of-package-registry">Size of Package Registry</a></h2>
<p>Compared to mainstream languages like Node.js, the Haskell ecosystem is much
smaller and has much less packages available. Despite that, the state
of the Hackage registry is pretty large, taking over 100 MiB after compression.</p>
<p>Capturing the entire state of the package registry is obviously not scaleable.
If the Haskell ecosystem were to grow to the size of Node.js, not only
the nixpkgs and Haskell packages in nixpkgs have to be re-architected,
but also Cabal itself has to come up with better ways of managing dependencies.</p>
<p>Compared to Cabal, package managers like npm and cargo do not simply download
the entire state of the package registries. Instead, the package registries
provide APIs for the package managers to query the available versions of
specific packages. This way, the local package managers only have to query
the relevant packages they need, and ignore the rest of the packages exist
in the registry.</p>
<p>This approach has the advantage of significantly reducing the bandwidth
required to compute the dependency graph. However since it requires network
communication, this cannot be used inside a Nix build. After all, there
is no way Nix can know if a package registry always give back the same
answer given the same set of queries.</p>
<h2><a class="header" href="#generating-nix-plans" id="generating-nix-plans">Generating Nix Plans</a></h2>
<p>Languages like Node.js and Rust come out with tools like
<a href="https://github.com/svanderburg/node2nix">node2nix</a> and
<a href="https://github.com/cargo2nix/cargo2nix">cargo2nix</a> to
convert the dependency resolution results directly into Nix expressions.</p>
<p>For these tools to work, they has to run outside of a Nix build to query
the package registry, and then generate the Nix expressions. Typically,
the Nix expressions are also derived directly from the lock files such as
<code>package-lock.json</code> and <code>Cargo.lock</code>.</p>
<p>The generated Nix expressions directly construct the dependency graph
required to build a Node.js or Rust project. When <code>nix-build</code> is called,
Nix can then easily use the dependency graph to download and build the
dependencies concurrently.</p>
<h2><a class="header" href="#similar-approach-in-haskell" id="similar-approach-in-haskell">Similar Approach In Haskell</a></h2>
<p>While there is a similarly named
<a href="https://github.com/NixOS/cabal2nix">cabal2nix</a> command for Haskell,
that is actually tied to the mono-versioning approach of nixpkgs.
As a result, cabal2nix never computes any dependency graph, but
instead simply generates a Nix expression that ask for the dependencies
from nixpkgs.</p>
<p>There is no reason why Haskell cannot adopt similar approaches as
node2nix or cargo2nix. It might be possible that such approaches are
more difficult to achieve, due to how Cabal and Hackage index works.
But that should not be an excuse to stop us from trying.</p>
<p>Whether to use Nix or not, if we want Haskell to gain wider adoption,
then the package manager Cabal needs
<a href="https://mail.haskell.org/pipermail/hf-discuss/2020-December/000003.html">significant improvement</a>
to be made. We need to improve Cabal to not just have better integrations
with tools like Nix and IDEs, but also make it much easier for users to
use.</p>
<h1><a class="header" href="#caching-nix-packages" id="caching-nix-packages">Caching Nix Packages</a></h1>
<p>Nix can be used to build all kinds of packages from the ground up. A Nix
packages can be as simple as a hello world output, or as large as projects
such as GHC and GCC. If every time we try to build our Nix package from
scratch together with all its dependencies, it is going to take unreasonably
long time.</p>
<p>Fortunately, NixOS provides cache for most packages provided by nixpkgs,
hosted at https://cache.nixos.org. This cache is usually enabled by default
in your local <code>nix.conf</code> file. Thanks to this, we can simply download
the packages in nixpkgs instead of building them from scratch.</p>
<p>The default cache from cache.nixos.org is usually sufficient if we are
just using Nix to build small projects. But what if we are using Nix to
build large projects that take hours to build? What if we need to
use Nix to build something like
<a href="06-infrastructure/../04-derivations/03-fibonacci/fib.nix"><code>fib(50)</code></a>?</p>
<h2><a class="header" href="#cachix" id="cachix">Cachix</a></h2>
<p><a href="https://cachix.org/">Cachix</a> is a cloud service for us to easily host our
own Nix cache. The service is free to use for public cache, and paid plan
is available for private Nix cache.</p>
<p>Other than Cachix, there are other options available for hosting Nix cache,
such as <a href="https://github.com/edolstra/nix-serve">nix-serve</a> and
<a href="https://github.com/NixOS/hydra">hydra</a>. However they require rolling up your
own infrastructure to host the servers, which can take quite a bit of effort.</p>
<p>Cachix is by far the easiest way to setup a Nix cache. In this section we
will go through the details of caching Nix packages using Cachix.
There are also <a href="https://docs.cachix.org">official documentation</a> available
on using Cachix, which you should check out.</p>
<p>To get started using Cachix, first sign up for an account at
https://app.cachix.org/signup. Or if you have already signed up, login
at https://app.cachix.org/login. After logging in, create a new
binary cache at https://app.cachix.org/cache.</p>
<p><img src="06-infrastructure/./images/create-cache.png" alt="Create Cache" /></p>
<p>Choose a unique name for your cache. For write access, leave with the default
option &quot;API tokens&quot;. We will also use the default public read access,
since our test cache do not contain sensitive data.</p>
<p>After creating the cache, we will also need to create an auth token to
push to our cache. Go to https://app.cachix.org/personal-auth-tokens
to generate one.</p>
<p><img src="06-infrastructure/./images/create-token.png" alt="Create Cache" /></p>
<p>Enter a suitable description for your Cachix token, then click the &quot;Generate&quot;
button.</p>
<p><img src="06-infrastructure/./images/create-token-2.png" alt="Create Cache" /></p>
<p>The web page will then show us the generated token, which we can later
enter in our shell. For the purpose of this workshop, also save the
auth token as <code>cachix-token</code> in the <a href="06-infrastructure/../../config">nix-workshop/config</a>
directory. (Remember to exclude the <code>cachix authtoken</code> prefix).</p>
<p>You should keep the generated token secret, as it can be used to push to
the Cachix store you own, as well as accessing private cache.
Having a proper description can help us identify the tokens that we are
no longer using, so that we can revoke them at a later time.</p>
<p>Now that we have setup our Cachix account, we can install Cachix on our local
machine using Nix:</p>
<pre><code class="language-bash">$ nix-channel --update
...
$ nix-env -i cachix
...
$ cachix --version
cachix 0.5.1
</code></pre>
<p>At the point of writing the version of our <code>cachix</code> command is <code>0.5.1</code>.
We can then configure Nix to use our Cachix store by running:</p>
<pre><code class="language-bash">cachix use my-awesome-nix-cache
</code></pre>
<p>(Replace the store name <code>my-awesome-nix-cache</code> with the Cachix store name
that you have created)</p>
<h2><a class="header" href="#docker" id="docker">Docker</a></h2>
<p>It is difficult to test whether a Nix cache works when using a single machine.
Since Nix also locally caches a Nix package after building it, we can't
really verify locally that Nix will download from our cache the next
time we build it on a fresh machine.</p>
<p>Although we could force rebuild everything using <code>nix-collect-garbage</code>, that
would also destroy all local builds we have. So we might not want to use that
nuclear option.</p>
<p>For the purpose of this workshop, we provide a <a href="06-infrastructure/../../Dockerfile">Dockerfile</a>
that you can use to enter an Ubuntu Docker container with fresh Nix environment.
You can enter the container by simply running:</p>
<pre><code class="language-bash">make docker
</code></pre>
<p>Inside the docker container, you can run as the <code>nix</code> user with the workshop
directory mounted at <code>~/nix-workshop</code>.</p>
<p>The Docker container is started with the <code>--rm</code> option, so storage for the
local Nix store is reclaimed when you exit the container. You can run
multiple copies of the container in separate shell, to test whether the
Nix packages are cached properly.</p>
<p>We still have to configure our Docker container to use the Cachix store
that we have just created. To simplify the configuration, save your
Cachix credentials in <a href="06-infrastructure/../../config">nix-workshop/config</a>, with
the file <code>cachix-store</code> containing the name of your Cachix store,
and <code>cachix-token</code> containing the auth token we have just created
earlier.</p>
<p>When entering the Docker container, it will automatically source
<a href="06-infrastructure/../../scripts/setup.sh"><code>scripts/setup.sh</code></a> to read the config
files and run the following:</p>
<pre><code class="language-bash">CACHIX_STORE=$(cat ~/nix-workshop/config/cachix-store)
cachix use $CACHIX_STORE
cachix authtoken $(cat ~/nix-workshop/config/cachix-token)
</code></pre>
<h2><a class="header" href="#caching-fibonacci" id="caching-fibonacci">Caching Fibonacci</a></h2>
<p>Now that our Cachix store is setup properly, we can try to actually
cache some Nix builds.
We will reuse the <a href="06-infrastructure/../04-derivations/03-fibonacci/fib.nix"><code>fib.nix</code></a>
derivation that we defined in earlier
<a href="06-infrastructure/../04-derivations/03-fibonacci.html">chapter</a>.</p>
<p>First of all, we use <code>nix-instantiate</code> to instantiate our Nix derivation,
and then save the result into <code>$drv</code>. We will create the <code>fib(4)</code> derivation
with the prefix <code>&quot;foo&quot;</code>. (You can choose your own prefix here)</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate -E '
  import ./code/04-derivations/03-fibonacci/fib.nix
    &quot;foo&quot; 4
')
...
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
</code></pre>
<p>When running <code>nix-instantiate</code>, it will produce the warning line
<code>warning: you did not specify '--add-root' ...</code> which we can usually ignore.</p>
<p>Now we can build <code>$drv</code>, which can take a while to finish.</p>
<pre><code class="language-bash">$ echo $drv
/nix/store/a4qb7vq7ws2q01jd5a07zpml5hw381nl-foo-fib-4.drv

$ nix-build --no-out-link $drv
...
/nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4
</code></pre>
<h3><a class="header" href="#single-build-output" id="single-build-output">Single Build Output</a></h3>
<p>Now that we have built our derivation, how do we actually cache it using
Cachix? At the most basic level, we can use <code>cachix push</code> to push
a particular Nix store path to Cachix:</p>
<pre><code class="language-bash">$ nix-build --no-out-link $drv | cachix push $CACHIX_STORE
compressing and pushing /nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4 (288.00 B)
All done.
</code></pre>
<p>In our naive attempt, we simply pipe the build output path of <code>fib(4)</code> to
<code>cachix push</code>. From the output we can see that Cachix has pushed a single path to
our store.</p>
<p>Now if we try to build <code>fib(4)</code> again in another container, we can see that
Nix would fetch the result directly from Cachix:</p>
<pre><code>$ nix-build --no-out-link $drv
these paths will be fetched (0.00 MiB download, 0.00 MiB unpacked):
  /nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4
copying path '/nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4' from 'https://scrive-nix-workshop.cachix.org'...
/nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4
</code></pre>
<p>Everything looks fine so far. But in fact <code>fib(0)</code> to <code>fib(3)</code> have
not yet been cached in our store. So Nix will still have to rebuild
the dependencies when they are needed, such as when entering
Nix shell:</p>
<pre><code class="language-bash">$ nix-shell $drv
these derivations will be built:
  /nix/store/6mc3ccymdyfmqacrq5vyc43zb2gl81ml-foo-fib-1.drv
  /nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv
  /nix/store/k65i01s85dix9xcgxyaggc8l13lx1rrz-foo-fib-2.drv
  /nix/store/wgcp26v3g23x9i9iqiirn20pgmv4mgki-foo-fib-3.drv
</code></pre>
<p>The dependencies also need to be rebuilt when we try to build something like
<code>fib(6)</code>, which depends on not only <code>fib(4)</code> but also <code>fib(3)</code>:</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate -E '
  import ./code/04-derivations/03-fibonacci/fib.nix
    &quot;foo&quot; 6
')
$ nix-build --no-out-link $drv
these derivations will be built:
  /nix/store/6mc3ccymdyfmqacrq5vyc43zb2gl81ml-foo-fib-1.drv
  /nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv
  /nix/store/k65i01s85dix9xcgxyaggc8l13lx1rrz-foo-fib-2.drv
  /nix/store/wgcp26v3g23x9i9iqiirn20pgmv4mgki-foo-fib-3.drv
  /nix/store/m3sspba1wz9ffp5qyjplg8fjbnhy7d73-foo-fib-5.drv
  /nix/store/zyhq28hxak4jk7xak6lixa4lbfxdjwvz-foo-fib-6.drv
...
</code></pre>
<h3><a class="header" href="#how-cachix-push-works" id="how-cachix-push-works">How <code>cachix push</code> works</a></h3>
<p>The <code>cachix push</code> command works by reading the Nix store paths from STDIN,
and push each of the path to the specified Cachix store. More specifically,
<code>cachix push</code> pushes the <em>closure</em> of the Nix path.</p>
<p>For the case above, the build result of <code>fib(4)</code> does not have any runtime
dependency, so only the build itself is pushed to Cachix.</p>
<p>We can also try pushing <code>fib-4.drv</code> itself to Cachix, and we can see that
it pushes the <code>.drv</code> derivation of all its dependencies as well.</p>
<pre><code>$ echo $drv | cachix push $CACHIX_STORE
compressing and pushing /nix/store/0hfyfy1wxlri4gdcmikg7v0ybvpkl3yl-Python-3.8.6.tar.xz.drv (856.00 B)
compressing and pushing /nix/store/0vjq3889mc2z9v02hcw072ay0fivbshx-nuke-references.drv (1.41 KiB)
compressing and pushing /nix/store/0rgf63snfi078knpghs1jf2q3913gd17-bootstrap-stage4-gcc-wrapper-10.2.0.drv (7.05 KiB)
...
compressing and pushing /nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv (1.41 KiB)
...
</code></pre>
<p>Similarly if we instead try to push the build result of
<a href="06-infrastructure/../04-derivations/02-dependencies/upper-greet.nix"><code>upper-greet.nix</code></a>,
we can see that the build result of
<a href="06-infrastructure/../04-derivations/02-dependencies/greet.nix"><code>greet.nix</code></a> is pushed as well.</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate ./code/04-derivations/02-dependencies/upper-greet.nix)
$ nix-build --no-out-link $drv | cachix push $CACHIX_STORE
these derivations will be built:
  /nix/store/wirssa651gwxv6z8ik78ac05c7f9ml3b-greet.drv
  /nix/store/aqznnbrbplwm2mvybzhp6wxw5inrq2aj-upper-greet.drv
...
compressing and pushing /nix/store/391ab6p11dh6gk4crc9a8pxym7c2v7lc-upper-greet (704.00 B)
compressing and pushing /nix/store/ws8lpdazs14zjcsgifkpdy060qsiakk6-greet (568.00 B)
All done.
</code></pre>
<p>However for neither approach can push the build output of <code>fib(0)</code> to <code>fib(3)</code>,
which are <em>build dependencies</em> of <code>fib(4)</code>.</p>
<h3><a class="header" href="#caching-build-dependencies" id="caching-build-dependencies">Caching Build Dependencies</a></h3>
<p>In practice, when we are are caching a derivation such as <code>fib(4)</code>, we would also
want to cache it together with all its build dependencies, including <code>fib(0)</code> to
<code>fib(3)</code> which we have just built. To do that we have to use <code>cachix push</code> together
with other Nix commands.</p>
<p>Recall that the <code>nix-store -qR</code> command gives us all the dependencies of a
derivation:</p>
<pre><code class="language-bash">$ nix-store -qR $drv
/nix/store/01n3wxxw29wj2pkjqimmmjzv7pihzmd7-which-2.21.tar.gz.drv
/nix/store/03f77phmfdmsbfpcc6mspjfff3yc9fdj-setup-hook.sh
...
</code></pre>
<p>We can <code>grep</code> specifically for the <code>fib</code> dependencies that we are interested in:</p>
<pre><code class="language-bash">$ nix-store -qR $drv | grep fib-
/nix/store/6mc3ccymdyfmqacrq5vyc43zb2gl81ml-foo-fib-1.drv
/nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv
/nix/store/k65i01s85dix9xcgxyaggc8l13lx1rrz-foo-fib-2.drv
/nix/store/wgcp26v3g23x9i9iqiirn20pgmv4mgki-foo-fib-3.drv
/nix/store/a4qb7vq7ws2q01jd5a07zpml5hw381nl-foo-fib-4.drv
</code></pre>
<p>To push the build result of all dependencies, we can add the
<code>--include-outputs</code> option:</p>
<pre><code class="language-bash">$ nix-store -qR --include-outputs $drv | grep fib-
/nix/store/20flzbyx97kly3n34krlmjg9awjn6a5z-foo-fib-3
/nix/store/52j5p1a03vi8dxn7rh4s8y6n5ml318rq-foo-fib-0
/nix/store/6mc3ccymdyfmqacrq5vyc43zb2gl81ml-foo-fib-1.drv
/nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv
/nix/store/k65i01s85dix9xcgxyaggc8l13lx1rrz-foo-fib-2.drv
/nix/store/wgcp26v3g23x9i9iqiirn20pgmv4mgki-foo-fib-3.drv
/nix/store/a4qb7vq7ws2q01jd5a07zpml5hw381nl-foo-fib-4.drv
/nix/store/c7lwn4mfn3pk0hhvc98lg1r6z6c8pb6c-foo-fib-1
/nix/store/qih0iazs5yl3dg694a2fz0jzzlxzy7k8-foo-fib-2
/nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4
</code></pre>
<p>Finally, we don't really need to push the <code>.drv</code> files themselves
to Cachix, as Nix always regenerate them during evaluation of the
<code>.nix</code> files. We can use <code>grep -v</code> to exclude them:</p>
<pre><code class="language-bash">$ nix-store -qR --include-outputs $drv | grep -v .drv | grep fib-
/nix/store/20flzbyx97kly3n34krlmjg9awjn6a5z-foo-fib-3
/nix/store/52j5p1a03vi8dxn7rh4s8y6n5ml318rq-foo-fib-0
/nix/store/c7lwn4mfn3pk0hhvc98lg1r6z6c8pb6c-foo-fib-1
/nix/store/qih0iazs5yl3dg694a2fz0jzzlxzy7k8-foo-fib-2
/nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4
</code></pre>
<p>Now that we got the list of build outputs to push, we can then pipe them
to <code>cachix push</code>:</p>
<pre><code class="language-bash">$ nix-build $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
compressing and pushing /nix/store/20flzbyx97kly3n34krlmjg9awjn6a5z-foo-fib-3 (288.00 B)
compressing and pushing /nix/store/52j5p1a03vi8dxn7rh4s8y6n5ml318rq-foo-fib-0 (288.00 B)
compressing and pushing /nix/store/c7lwn4mfn3pk0hhvc98lg1r6z6c8pb6c-foo-fib-1 (288.00 B)
compressing and pushing /nix/store/qih0iazs5yl3dg694a2fz0jzzlxzy7k8-foo-fib-2 (288.00 B)
compressing and pushing /nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4 (288.00 B)
All done.
</code></pre>
<p>This time if we try to build <code>fib(6)</code> on a fresh machine, it will download the cache
result of both <code>fib(3)</code> and <code>fib(4)</code> from Cachix:</p>
<pre><code class="language-bash">$ nix-build -E '
  import ./code/04-derivations/03-fibonacci/fib.nix
    &quot;foo&quot; 6
'
these derivations will be built:
  /nix/store/m3sspba1wz9ffp5qyjplg8fjbnhy7d73-foo-fib-5.drv
  /nix/store/zyhq28hxak4jk7xak6lixa4lbfxdjwvz-foo-fib-6.drv
these paths will be fetched (61.76 MiB download, 260.53 MiB unpacked):
  /nix/store/20flzbyx97kly3n34krlmjg9awjn6a5z-foo-fib-3
  /nix/store/zdq2p21pq836n3k1xkh4yb8wkvl9fy0l-foo-fib-4
  ...
building '/nix/store/m3sspba1wz9ffp5qyjplg8fjbnhy7d73-foo-fib-5.drv'...
...
building '/nix/store/zyhq28hxak4jk7xak6lixa4lbfxdjwvz-foo-fib-6.drv'...
...
/nix/store/vrzxqqj6q11lgpizsd78r2cx2c7zfban-foo-fib-6
</code></pre>
<h2><a class="header" href="#evaluation-time-dependencies-1" id="evaluation-time-dependencies-1">Evaluation-time Dependencies</a></h2>
<p>As mentioned in
<a href="06-infrastructure/../04-derivations/03-fibonacci.html#evaluation-time-dependencies">chapter 14</a>,
It is much more tricky to find the evaluation time dependencies and
push them to Cachix.</p>
<p>If we try to Cache the build dependencies of
<a href="06-infrastructure/../04-derivations/03-fibonacci/fib-serialized.nix"><code>fib-serialized.nix</code></a>,
it wouldn't really workd.</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate -E '
  import ./code/04-derivations/03-fibonacci/fib-serialized.nix
    &quot;foo&quot; 4
')
building '/nix/store/6mc3ccymdyfmqacrq5vyc43zb2gl81ml-foo-fib-1.drv'...
...
building '/nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv'...
...
building '/nix/store/bg0kqrl14p99y1k0g47gcx7a4ik4qk1m-foo-fib-3.drv'...
...

$ nix-build $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
compressing and pushing /nix/store/rlllddnljlv1qzlizdr97q5wbzlqpq5k-foo-fib-4 (288.00 B)
All done.
</code></pre>
<p>At this point, there is no simple way to find out all evaluation time
dependencies to push. But in case we really want to push all evaluation time
dependencies, there is still one nuclear option</p>
<h2><a class="header" href="#push-all-nix-derivations" id="push-all-nix-derivations">Push All Nix Derivations</a></h2>
<p><code>cachix push</code> provides a <code>watch-exec</code> command to watch the global Nix
store, and push <em>all</em> new paths that are added to the Nix store during the
execution of our command.</p>
<pre><code class="language-bash">$ cachix watch-exec $CACHIX_STORE nix-build -- \
  --no-out-link \
  -E 'import ./code/04-derivations/03-fibonacci/fib-serialized.nix
    &quot;foo&quot; 4'
...
Watching /nix/store for new store paths ...
building '/nix/store/hj0g7hn703axx44x29l27xb1nrdg83rh-foo-fib-0.drv'...
compressing and pushing /nix/store/52j5p1a03vi8dxn7rh4s8y6n5ml318rq-foo-fib-0 (288.00 B)
building '/nix/store/6mc3ccymdyfmqacrq5vyc43zb2gl81ml-foo-fib-1.drv'...
...
compressing and pushing /nix/store/c7lwn4mfn3pk0hhvc98lg1r6z6c8pb6c-foo-fib-1 (288.00 B)
building '/nix/store/74x1nl7paqin5zcrkkj94bbkm25shpx9-foo-fib-2.drv'...
...
compressing and pushing /nix/store/ia5arkikhbyd9drjzxm2lqgr5a1b6n9m-foo-fib-2 (288.00 B)
building '/nix/store/bg0kqrl14p99y1k0g47gcx7a4ik4qk1m-foo-fib-3.drv'...
...
compressing and pushing /nix/store/ykvgv0hvpm93glrjzpyb7hkashq5rr1q-foo-fib-3 (288.00 B)
these derivations will be built:
  /nix/store/m25lspbpyv09vl3pz3sf3q20ndcrilq9-foo-fib-4.drv
building '/nix/store/m25lspbpyv09vl3pz3sf3q20ndcrilq9-foo-fib-4.drv'...
...
/nix/store/rlllddnljlv1qzlizdr97q5wbzlqpq5k-foo-fib-4
Stopped watching /nix/store and waiting for queue to empty ...
compressing and pushing /nix/store/rlllddnljlv1qzlizdr97q5wbzlqpq5k-foo-fib-4 (288.00 B)
Waiting to finish: 1 pushing, 0 in queue
Done.
</code></pre>
<p>We can see during the build that Nix pushes a lot of things to Cachix, including all the
intermediary <code>.drv</code> files and also the downloaded tarballs from sources like nixpkgs,
which are in fact also evaluation time dependencies.</p>
<p>Now if we go to a fresh machine and try to build <code>fib-serialized</code>, we can see
that this time it is correctly downloading the build results of <code>fib(0)</code> to
<code>fib(4)</code> from Cachix:</p>
<pre><code class="language-bash">$ nix-build -E '
  import ./code/04-derivations/03-fibonacci/fib-serialized.nix
    &quot;foo&quot; 6'
...
copying path '/nix/store/c7lwn4mfn3pk0hhvc98lg1r6z6c8pb6c-foo-fib-1' from 'https://scrive-nix-workshop.cachix.org'...
copying path '/nix/store/52j5p1a03vi8dxn7rh4s8y6n5ml318rq-foo-fib-0' from 'https://scrive-nix-workshop.cachix.org'...
copying path '/nix/store/ia5arkikhbyd9drjzxm2lqgr5a1b6n9m-foo-fib-2' from 'https://scrive-nix-workshop.cachix.org'...
copying path '/nix/store/ykvgv0hvpm93glrjzpyb7hkashq5rr1q-foo-fib-3' from 'https://scrive-nix-workshop.cachix.org'...
copying path '/nix/store/rlllddnljlv1qzlizdr97q5wbzlqpq5k-foo-fib-4' from 'https://scrive-nix-workshop.cachix.org'...
...
building '/nix/store/9ykk0mg8b72nr73hfb82vs49pfyqinzg-foo-fib-5.drv'...
...
these derivations will be built:
  /nix/store/wfqhsi5rccz5wb620axn1w3sbjhalw1s-foo-fib-6.drv
building '/nix/store/wfqhsi5rccz5wb620axn1w3sbjhalw1s-foo-fib-6.drv'...
/nix/store/7rx619rpisnh9sw2g3sk6yq07jb563yh-foo-fib-6
</code></pre>
<p>The <code>-w</code> option provides very coarse-grained control for caching everything to
Cachix. This can be useful if we do not care about what is being cached, and
instead just want to cache everything.</p>
<p>However as we will see in the next chapter, there might be things that we
do <em>not</em> want to cache to Cachix, such as proprietary source code or
secret credentials.</p>
<h1><a class="header" href="#caching-haskell-nix-packages" id="caching-haskell-nix-packages">Caching Haskell Nix Packages</a></h1>
<p>Similar to the previous chapter, we can cache our Haskell.nix project in similar way.</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate ./code/05-package-management/haskell-project-v3/nix/07-haskell.nix-materialized)

$ nix-build $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
...
/nix/store/8vrdfinxxnwczn4jzknm44bsn3k5nghl-haskell-project-exe-hello-0.1.0.0
compressing and pushing /nix/store/8vrdfinxxnwczn4jzknm44bsn3k5nghl-haskell-project-exe-hello-0.1.0.0 (3.60 MiB)
compressing and pushing /nix/store/6apx83l6ss3hkn0kd4z4rkjbkgs0w4w2-default-Setup-setup (18.07 MiB)
compressing and pushing /nix/store/3pfy3dd8ch77km1wkwd6cdgqn57d4347-haskell-project-exe-hello-0.1.0.0-config (304.02 KiB)
compressing and pushing /nix/store/b2j1nrsjr8cpzmk58d476fc2snz17w75-ghc-8.10.2 (1.71 GiB)
...
All done.
</code></pre>
<p>As simple as it might look, the naive approach however has some flaws,
especially when dealing with private projects.</p>
<h2><a class="header" href="#leaking-source-code" id="leaking-source-code">Leaking Source Code</a></h2>
<p>The first issue with pushing everything is source code contamination, i.e.
the source code of the project leaking to the cache. For instance, suppose
we modify the <a href="06-infrastructure/../05-package-management/haskell-project-v3/haskell/Main.hs">main</a>
function to print &quot;Hello, World!&quot; instead of &quot;Hello, Haskell!&quot;:</p>
<pre><code class="language-bash">$ sed -i 's/Hello, Haskell!/Hello, World!/g' ./code/05-package-management/haskell-project-v3/haskell/Main.hs
$ cat ./code/05-package-management/haskell-project-v3/haskell/Main.hs
module Main where

main :: IO ()
main = putStrLn &quot;Hello, World!&quot;
</code></pre>
<p>If we try to rebuild our Haskell project and push it to Cachix, we can notice
that the modified source code is also pushed as well.
(Notice the <code>drv=$(nix-instantiate ...)</code> assignment has to be re-run to get the
new derivation with the modified source)</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate ./code/05-package-management/haskell-project-v3/nix/07-haskell.nix-materialized)
$ nix-build $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
...
/nix/store/hkqkig7y1dx96qbdwkhk0anb0xdmx6hm-haskell-project-exe-hello-0.1.0.0
compressing and pushing /nix/store/hkqkig7y1dx96qbdwkhk0anb0xdmx6hm-haskell-project-exe-hello-0.1.0.0 (3.60 MiB)
compressing and pushing /nix/store/wq6ry5x7b5x3ld0d7wd2wx3vkxp4wi66-haskell-project-src (1.49 KiB)
All done.
</code></pre>
<p>We can list the files in <code>/nix/store/6a049f3fv8x2rdxv34k14cxrwi9an43f-haskell-project-src</code>
and verify that it indeed contains our modified source code. Yikes!</p>
<pre><code class="language-bash">$ ls -la /nix/store/6a049f3fv8x2rdxv34k14cxrwi9an43f-haskell-project-src
total 180
dr-xr-xr-x 2 user user   4096 Jan  1  1970 .
drwxr-xr-x 1 user user 151552 Jan  7 15:41 ..
-r--r--r-- 1 user user     15 Jan  1  1970 .gitignore
-r--r--r-- 1 user user     65 Jan  1  1970 Main.hs
-r--r--r-- 1 user user     46 Jan  1  1970 Setup.hs
-r--r--r-- 1 user user     12 Jan  1  1970 cabal.project
-r--r--r-- 1 user user    307 Jan  1  1970 haskell-project.cabal

$ cat /nix/store/6a049f3fv8x2rdxv34k14cxrwi9an43f-haskell-project-src/Main.hs
module Main where

main :: IO ()
main = putStrLn &quot;Hello, World!&quot;
</code></pre>
<p>Pushing source code to Cachix might not be a big deal for open source projects.
However this may be an issue for propritary projects with strict IP policies.
This could be partially mitigated by having a private Cachix store. But we
just have to be aware of it and be careful.</p>
<h2><a class="header" href="#leaking-secrets" id="leaking-secrets">Leaking Secrets</a></h2>
<p>Even for the case of open source projects, indiscriminately pushing everything
to Cachix still carries another risk, which is accidentally leaking secrets
such as authentication credentials.</p>
<p>Suppose that we have some security credentials stored locally in the <code>secret.key</code>
file in the project directory. Since the file is included in <code>.gitignore</code>, it is
not pushed to the git repository.</p>
<pre><code class="language-bash">$ echo secret &gt; ./code/05-package-management/haskell-project-v3/haskell/secret.key
$ ls -la ./code/05-package-management/haskell-project-v3/haskell/
total 32
drwxrwxr-x 2 user user 4096 Jan  7 15:58 .
drwxrwxr-x 4 user user 4096 Dec  8 08:23 ..
-rw-rw-r-- 1 user user   26 Jan  7 15:58 .gitignore
-rw-r--r-- 1 user user   67 Jan  7 15:45 Main.hs
-rw-r--r-- 1 user user   46 Dec  7 08:37 Setup.hs
-rw-rw-r-- 1 user user   12 Dec  7 08:37 cabal.project
-rw-rw-r-- 1 user user  307 Jan  7 09:35 haskell-project.cabal
-rw-rw-r-- 1 user user    7 Jan  7 15:58 secret.key
</code></pre>
<p>But is <code>secret.key</code> being included when pushing to Cachix? Let's find out:</p>
<pre><code>$ drv=$(nix-instantiate ./code/05-package-management/haskell-project-v3/nix/07-haskell.nix-materialized)
$ nix-build $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
...
compressing and pushing /nix/store/nrmyzkww87ndyp44jkn56hrra8m9d9vy-haskell-project-exe-hello-0.1.0.0 (3.60 MiB)
compressing and pushing /nix/store/ryz8an9z9bw7j1357k9b5w99fxvnhb74-haskell-project-src (1.69 KiB)
All done.

$ ls -la /nix/store/ryz8an9z9bw7j1357k9b5w99fxvnhb74-haskell-project-src
total 188
dr-xr-xr-x 2 user user   4096 Jan  1  1970 .
drwxr-xr-x 1 user user 155648 Jan  7 16:00 ..
-r--r--r-- 1 user user     26 Jan  1  1970 .gitignore
-r--r--r-- 1 user user     67 Jan  1  1970 Main.hs
-r--r--r-- 1 user user     46 Jan  1  1970 Setup.hs
-r--r--r-- 1 user user     12 Jan  1  1970 cabal.project
-r--r--r-- 1 user user    307 Jan  1  1970 haskell-project.cabal
-r--r--r-- 1 user user      7 Jan  1  1970 secret.key

$ cat /nix/store/ryz8an9z9bw7j1357k9b5w99fxvnhb74-haskell-project-src/secret.key
secret
</code></pre>
<p>That's not good! Our local security credentials have been leaked to Cachix!
If we also have a public Cachix store, the credentials can potentially be obtained
by anyone!</p>
<p>The real culprit is in how we create our source derivation in
<a href="06-infrastructure/../05-package-management/haskell-project-v3/nix/07-haskell.nix-materialized/project.nix"><code>project.nix</code></a>:</p>
<pre><code class="language-nix">src = builtins.path {
  name = &quot;haskell-project-src&quot;;
  path = ../../haskell;
  filter = path: type:
    let
      basePath = builtins.baseNameOf path;
    in
    basePath != &quot;dist-newstyle&quot;
  ;
};
</code></pre>
<p>Previously, we made a naive attempt of filtering our source directory and
excluding only the <code>dist-newstyle</code> directory to avoid rebuilding the Nix
build when the directory is modified by local <code>cabal</code> runs. However if
we want to push our source code to Cachix, we better be much more careful.</p>
<h2><a class="header" href="#gitignorenix" id="gitignorenix">Gitignore.nix</a></h2>
<p>One way we can protect local secrets is by filtering out all gitignored
files so that our source code is close to a fresh git checkout when copied
into the Nix store. This can be done using Nix helper libraries such as
<a href="https://github.com/hercules-ci/gitignore.nix">gitignore.nix</a>.</p>
<p>Using gitignore.nix, we can now create a new
<a href="06-infrastructure/./haskell-project-v4">haskell-project-v4</a> project with the source
filtered with gitignore.nix:</p>
<pre><code class="language-nix">gitignore = (import sources.&quot;gitignore.nix&quot; {
  inherit (nixpkgs) lib;
}).gitignoreSource;

src = nixpkgs.lib.cleanSourceWith {
  name = &quot;haskell-project-src&quot;;
  src = gitignore ../../haskell;
};
</code></pre>
<p>We first add <code>gitignore.nix</code> into <code>sources</code> using <code>niv</code>, and then import
it as above. Following that, we use <code>gitignore ../../haskell</code> to
filter the gitignored files in the <code>haskell</code> directory. We then
use <code>nixpkgs.lib.cleanSourceWith</code> as a hack to give the filtered source a
name <code>haskell-project-src</code>, so that we can grep for it during inspection.</p>
<p>Now if we try to build our derivation, we should get the project source with
the local secret filtered out:</p>
<pre><code class="language-bash">$ drv=$(nix-instantiate ./code/06-infrastructure/haskell-project-v4/nix/01-gitignore-src)
$ nix-store -qR --include-outputs $drv | grep haskell-project-src
/nix/store/mhlj5xql8g6ib1wna4g9pc6cpraiz1q8-haskell-project-src-root

$ ls -la /nix/store/mhlj5xql8g6ib1wna4g9pc6cpraiz1q8-haskell-project-src-root
total 140
dr-xr-xr-x 2 nix nix   4096 Jan  1  1970 .
drwxr-xr-x 1 nix nix 114688 Jan 11 11:21 ..
-r--r--r-- 1 nix nix     26 Jan  1  1970 .gitignore
-r--r--r-- 1 nix nix     67 Jan  1  1970 Main.hs
-r--r--r-- 1 nix nix     46 Jan  1  1970 Setup.hs
-r--r--r-- 1 nix nix     12 Jan  1  1970 cabal.project
-r--r--r-- 1 nix nix    307 Jan  1  1970 haskell-project.cabal
</code></pre>
<h3><a class="header" href="#caveats" id="caveats">Caveats</a></h3>
<p>Gitignore.nix can help us filter out files specified in <code>.gitignore</code>.
However it might still be possible that developers would add new secrets
locally without adding them to <code>.gitignore</code>. In such case, the secret
can still potentially leak to Cachix.</p>
<p>The best way to prevent secrets from leaking is to build from a published
git or tarball URL. That way it will be less likely for us to accidentally
mix up and leak the secrets in our local file systems. This will
however require more complex project organization, as we have to place
the Nix code separately from the source code.</p>
<p>Otherwise, it is still recommended to avoid pushing source code to
Cachix in the first place, both for proprietary and open source projects.
After all, users will almost always build a Nix project with their own
local source code, or source that are fetched directly from git or
remote URLs. There is rarely a need to use Cachix to distribute source
code to our users.</p>
<h2><a class="header" href="#filtering-out-source" id="filtering-out-source">Filtering Out Source</a></h2>
<p>One simple way to filter out the source code is to filter out the name
of the source derivation using <code>grep</code> before pushing to Cachix:</p>
<pre><code class="language-bash">$ nix-store -qR --include-outputs $drv \
  | grep -v .drv | grep -v haskell-project-src \
  | cachix push $CACHIX_STORE
</code></pre>
<p>Note however this may only work if no other paths pushed to Cachix depends
on the source code. This is because Cachix automatically pushes the whole
closure of a Nix path. For instance this would not work if we try to push
the <code>.drv</code> file of the build derivation to Cachix, because that would
also capture the source derivation as part of the closure.</p>
<p>This approach also would not work if there are some intermediate derivations
that make copy of the original source code and modify them to produce
new source derivation. The intermediate derivation may have a different
name, or even a generic one, which it would be difficult for us to filter
out without inspecting the derivation source.</p>
<p>As a result, it is best to make use of the <code>patchPhase</code> in
<code>stdenv.mkDerivation</code> to modify the source code if necessary.</p>
<h2><a class="header" href="#caching-nix-shell" id="caching-nix-shell">Caching Nix Shell</a></h2>
<p>Another way to exclude source code from derivation is by creating a Nix shell
derivation and cache that instead. Haskell.nix provides a <code>shellFor</code>
function that creates a Nix shell derivation from the original
Haskell.nix project we defined.</p>
<pre><code class="language-nix">{ useMaterialization ? true }:
let
  project = import ./project.nix {
    inherit useMaterialization;
  };
in
project.shellFor {
  withHoogle = false;
}
</code></pre>
<p>If we inspect the derivation tree from <code>shell.nix</code>, we can confirm that
indeed the source code not present in the list. And so we can
safely push only the Haskell.nix dependencies to Cachix.</p>
<pre><code class="language-bash">drv=$(nix-instantiate ./code/06-infrastructure/haskell-project-v4/nix/01-gitignore-src/shell.nix)

$ nix-store -qR --include-outputs $drv | grep haskell-project-src
</code></pre>
<p>We first use <code>nix-shell --run true $drv</code> to build only the dependencies of our shell derivation and
push them to Cachix.</p>
<pre><code class="language-bash">$ nix-shell --run true $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
...
All done.
</code></pre>
<p>If we want to cache the final build artifact as well, we can still run <code>nix-build $drv</code> and
then push <em>only</em> the build output to Cachix.</p>
<pre><code class="language-bash">$ nix-build ./code/06-infrastructure/haskell-project-v4/nix/01-gitignore-src | cachix push $CACHIX_STORE
...
compressing and pushing /nix/store/9in65nlw9s255x8zh5g7hlvbnl23rqbz-haskell-project-exe-hello-0.1.0.0 (3.60 MiB)
All done.
</code></pre>
<h2><a class="header" href="#double-check-leaking-with-code-changes" id="double-check-leaking-with-code-changes">Double Check Leaking with Code Changes</a></h2>
<p>Our attempt to cache only the Nix shell derivation seems to exclude the source code,
but is it really excluded? If we are not careful, we could easily let Nix give a
generic name like <code>source</code> to our source derivation. In that case it would not
be possible to detect it through <code>grep</code> if our source code has leaked through.</p>
<p>As a result, it is best to double check what is being cached by slightly modifying
our source code, and then try pushing to Cachix again.</p>
<pre><code class="language-bash">$ sed -i 's/Hello, Haskell!/Hello, World!/g' ./code/06-infrastructure/haskell-project-v4/haskell/Main.hs
$ cat ./code/06-infrastructure/haskell-project-v4/haskell/Main.hs
module Main where

main :: IO ()
main = putStrLn &quot;Hello, World!&quot;

$ drv=$(nix-instantiate ./code/06-infrastructure/haskell-project-v4/nix/01-gitignore-src/shell.nix)
$ nix-shell --run true $drv &amp;&amp; nix-store -qR --include-outputs $drv | grep -v .drv | cachix push $CACHIX_STORE
All done.

$ nix-build ./code/06-infrastructure/haskell-project-v4/nix/01-gitignore-src | cachix push $CACHIX_STORE
these derivations will be built:
  /nix/store/52qqdj4pq564ivyawpvfzsz2s3kv9wmp-haskell-project-exe-hello-0.1.0.0.drv
...
compressing and pushing /nix/store/fdb6b3dj79gqff0lz0xf34lrs4gpb5a0-haskell-project-exe-hello-0.1.0.0 (3.60 MiB)
All done.
</code></pre>
<p>As we expect, even though <code>Main.hs</code> has been modified, there is no new source
artifact being pushed to Cachix. Only <code>nix-build</code> produced a new binary, which
is then pushed to Cachix.</p>
<p>You can apply the same method on your own project to double check if your
source code is leaking to Cachix. Even if you do not care about the source
code leaking, this can still serve as a good way to check if any secret
is leaking.</p>
<h2><a class="header" href="#caching-multiple-projects" id="caching-multiple-projects">Caching Multiple Projects</a></h2>
<p>The technique for caching Nix shell can only work if we have projects made of a
single Nix derivation. If we instead have a large project with multiple source
repositories, it is much harder to filter out the source code if the derivations
depend on each others.</p>
<p>In such cases, the simple way is to use <code>grep -v</code> and hope that it can filter
out all the source derivations. Otherwise you may need to use project-specific
techniques to make sure that only intended Nix artifacts are being cached.</p>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>As we seen in this chapter, caching build results is not as straighforward if
there are things that we want to <em>prevent</em> from being cached, such as proprietary
source code or local secrets. This is probably not a big issue right now, because
many people may not even be aware that their source code and secrets are leaking!</p>
<p>Even without considering leaking secrets, there are still too many different ways
of caching build results in Nix. While this provides more flexibility for us
to control what to cache, the learning curve is way too high for new users
who just want to get their Nix builds cached.</p>
<p>Nix and Cachix may need to implement additional features to help make caching
easier, and to protect sensitive data. For example, Cachix may add a command
line option to exclude paths matching specific pattern to never be pushed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
